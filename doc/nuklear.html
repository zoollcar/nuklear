<meta charset='utf-8' emacsmode='-*- markdown -*-'>
<link rel='stylesheet' href='https://casual-effects.com/markdeep/latest/apidoc.css?'>
# Nuklear![](https://cloud.githubusercontent.com/assets/8057201/11761525/ae06f0ca-a0c6-11e5-819d-5610b25f6ef4.gif)## 目录1. 关于部分2. 亮点部分3. 特色部分4. 用法部分    1. 标志部分    2. 常亮部分    3. 依赖部分5. 示例部分6. API 部分    1. Context 部分    2. Input 部分    3. Drawing 部分    4. Window 部分    5. Layouting 部分    6. Groups 部分    7. Tree 部分    8. Properties 部分7. 许可协议8. 更新日志9. 画廊10. 荣誉名单## 关于This is a minimal state immediate mode graphical user interface toolkitwritten in ANSI C and licensed under public domain. It was designed as a simpleembeddable user interface for application and does not have any dependencies,a default renderbackend or OS window and input handling but instead provides a very modularlibrary approach by using simple input state for input and drawcommands describing primitive shapes as output. So instead of providing alayered library that tries to abstract over a number of platform andrender backends it only focuses on the actual UI.## 亮点- Graphical user interface toolkit- Single header library- Written in C89 (a.k.a. ANSI C or ISO C90)- Small codebase (~18kLOC)- Focus on portability, efficiency and simplicity- No dependencies (not even the standard library if not wanted)- Fully skinnable and customizable- Low memory footprint with total memory control if needed or wanted- UTF-8 support- No global or hidden state- Customizable library modules (you can compile and use only what you need)- Optional font baker and vertex buffer output## 特色- Absolutely no platform dependent code- Memory management control ranging from/to    - Ease of use by allocating everything from standard library    - Control every byte of memory inside the library- Font handling control ranging from/to    - Use your own font implementation for everything    - Use this libraries internal font baking and handling API- Drawing output control ranging from/to    - Simple shapes for more high level APIs which already have drawing capabilities    - Hardware accessible anti-aliased vertex buffer output- Customizable colors and properties ranging from/to    - Simple changes to color by filling a simple color table    - Complete control with ability to use skinning to decorate widgets- Bendable UI library with widget ranging from/to    - Basic widgets like buttons, checkboxes, slider, ...    - Advanced widget like abstract comboboxes, contextual menus,...- Compile time configuration to only compile what you need    - Subset which can be used if you do not want to link or use the standard library- Can be easily modified to only update on user input instead of frame updates## 用法This library is self contained in one single header file and can be used eitherin header only mode or in implementation mode. The header only mode is usedby default when included and allows including this header in other headersand does not contain the actual implementation. The implementation mode requires to define  the preprocessor macroNK_IMPLEMENTATION in *one* .c/.cpp file before #includeing this file, e.g.:使用它需要在程序开头定义一个宏和引入一个头文件~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~C    #define NK_IMPLEMENTATION    #include "nuklear.h"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Also optionally define the symbols listed in the section "OPTIONAL DEFINES"below in header and implementation mode if you want to use additional 函数alityor need more control over the library.!!! WARNING    Every time nuklear is included define the same compiler flags. This very important not doing so could lead to compiler errors or even worse stack corruptions.### 标志部分Flag                            | 描述--------------------------------|------------------------------------------NK_PRIVATE                      | If defined declares all 函数s as static, so they can only be accessed inside the file that contains the implementationNK_INCLUDE_FIXED_TYPES          | 如果这样，它将包含固定大小和类型头文件`<stdint.h>` ，而不是尝试选择正确的类型。这将可以防止编译器错误NK_INCLUDE_DEFAULT_ALLOCATOR    | 如果这样，它将包含头文件 `<stdlib.h>` and provide additional 函数s to use this library without caring for memory allocation control and therefore 简化内存管理。NK_INCLUDE_STANDARD_IO          | 如果这样，它将包含头文件 `<stdio.h>` 并根据文件加载提供附加功能。NK_INCLUDE_STANDARD_VARARGS     | 如果这样，它将包含头文件 `<stdio.h>` 并根据文件加载提供附加功能。和NK_INCLUDE_STANDARD_IO一样NK_INCLUDE_VERTEX_BUFFER_OUTPUT | Defining this adds a vertex draw command list backend to this library, which allows you to convert queue commands into vertex draw commands. This is mainly if you need a hardware accessible format for OpenGL, DirectX, Vulkan, Metal,...NK_INCLUDE_FONT_BAKING          | Defining this adds `stb_truetype` and `stb_rect_pack` implementation to this library and provides font baking and rendering. If you already have font handling or do not want to use this font handler you don't have to define it.NK_INCLUDE_DEFAULT_FONT         | Defining this adds the default font: ProggyClean.ttf into this library which can be loaded into a font atlas and allows using this library without having a truetype fontNK_INCLUDE_COMMAND_USERDATA     | Defining this adds a userdata pointer into each command. Can be useful for example if you want to provide custom shaders depending on the used widget. Can be combined with the style structures.NK_BUTTON_TRIGGER_ON_RELEASE    | Different platforms require button clicks occurring either on buttons being pressed (up to down) or released (down to up). By default this library will react on buttons being pressed, but if you define this it will only trigger if a button is released.NK_ZERO_COMMAND_MEMORY          | Defining this will zero out memory for each drawing command added to a drawing queue (inside nk_command_buffer_push). Zeroing command memory is very useful for fast checking (using memcmp) if command buffers are equal and avoid drawing frames when nothing on screen has changed since previous frame.!!! WARNING    The following flags will pull in the standard C library:    - NK_INCLUDE_DEFAULT_ALLOCATOR    - NK_INCLUDE_STANDARD_IO    - NK_INCLUDE_STANDARD_VARARGS!!! WARNING    The following flags if defined need to be defined for both header and implementation:    - NK_INCLUDE_FIXED_TYPES    - NK_INCLUDE_DEFAULT_ALLOCATOR    - NK_INCLUDE_STANDARD_VARARGS    - NK_INCLUDE_VERTEX_BUFFER_OUTPUT    - NK_INCLUDE_FONT_BAKING    - NK_INCLUDE_DEFAULT_FONT    - NK_INCLUDE_STANDARD_VARARGS    - NK_INCLUDE_COMMAND_USERDATA### 常量Define                          | 描述--------------------------------|---------------------------------------NK_BUFFER_DEFAULT_INITIAL_SIZE  | Initial buffer size allocated by all buffers while using the default allocator 函数s included by defining NK_INCLUDE_DEFAULT_ALLOCATOR. If you don't want to allocate the default 4k memory then redefine it.NK_MAX_NUMBER_BUFFER            | Maximum buffer size for the conversion buffer between float and string Under normal circumstances this should be more than sufficient.NK_INPUT_MAX                    | Defines the max number of bytes which can be added as text input in one frame. Under normal circumstances this should be more than sufficient.!!! WARNING    The following constants if defined need to be defined for both header and implementation:    - NK_MAX_NUMBER_BUFFER    - NK_BUFFER_DEFAULT_INITIAL_SIZE    - NK_INPUT_MAX### 依赖关系------------|---------------------------------------------------------------NK_ASSERT   | If you don't define this, nuklear will use <assert.h> with assert().NK_MEMSET   | You can define this to 'memset' or your own memset implementation replacement. If not nuklear will use its own version.NK_MEMCPY   | You can define this to 'memcpy' or your own memcpy implementation replacement. If not nuklear will use its own version.NK_SQRT     | You can define this to 'sqrt' or your own sqrt implementation replacement. If not nuklear will use its own slow and not highly accurate version.NK_SIN      | You can define this to 'sinf' or your own sine implementation replacement. If not nuklear will use its own approximation implementation.NK_COS      | You can define this to 'cosf' or your own cosine implementation replacement. If not nuklear will use its own approximation implementation.NK_STRTOD   | You can define this to `strtod` or your own string to double conversion implementation replacement. If not defined nuklear will use its own imprecise and possibly unsafe version (does not handle nan or infinity!).NK_DTOA     | You can define this to `dtoa` or your own double to string conversion implementation replacement. If not defined nuklear will use its own imprecise and possibly unsafe version (does not handle nan or infinity!).NK_VSNPRINTF| If you define `NK_INCLUDE_STANDARD_VARARGS` as well as `NK_INCLUDE_STANDARD_IO` and want to be safe define this to `vsnprintf` on compilers supporting later versions of C or C++. By default nuklear will check for your stdlib version in C as well as compiler version in C++. if `vsnprintf` is available it will define it to `vsnprintf` directly. If not defined and if you have older versions of C or C++ it will be defined to `vsprintf` which is unsafe.!!! WARNING    The following dependencies will pull in the standard C library if not redefined:    - NK_ASSERT!!! WARNING    The following dependencies if defined need to be defined for both header and implementation:    - NK_ASSERT!!! WARNING    The following dependencies if defined need to be defined only for the implementation part:    - NK_MEMSET    - NK_MEMCPY    - NK_SQRT    - NK_SIN    - NK_COS    - NK_STRTOD    - NK_DTOA    - NK_VSNPRINTF## Example 例子~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c// 初始化 gui 状态enum {EASY, HARD};static int op = EASY;static float value = 0.6f;static int i =  20;struct nk_context ctx;nk_init_fixed(&ctx, calloc(1, MAX_MEMORY), MAX_MEMORY, &font);if (nk_begin(&ctx, "Show", nk_rect(50, 50, 220, 220),    NK_WINDOW_BORDER|NK_WINDOW_MOVABLE|NK_WINDOW_CLOSABLE)) {    // 固定小部件像素宽度    nk_layout_row_static(&ctx, 30, 80, 1);    if (nk_button_label(&ctx, "button")) {        // event handling    }    // 固定小部件宽高比    nk_layout_row_dynamic(&ctx, 30, 2);    if (nk_option_label(&ctx, "easy", op == EASY)) op = EASY;    if (nk_option_label(&ctx, "hard", op == HARD)) op = HARD;    // 自定义小部件像素宽度    nk_layout_row_begin(&ctx, NK_STATIC, 30, 2);    {        nk_layout_row_push(&ctx, 50);        nk_label(&ctx, "Volume:", NK_TEXT_LEFT);        nk_layout_row_push(&ctx, 110);        nk_slider_float(&ctx, 0, &value, 1.0f, 0.1f);    }    nk_layout_row_end(&ctx);}nk_end(&ctx);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~![](https://cloud.githubusercontent.com/assets/8057201/10187981/584ecd68-675c-11e5-897c-822ef534a876.png)## API### ContextContext 是主入口 是 nuklear 的核心，它包含所有需要的东西.Context 被 window, memory, input, style, stack, commands 和 time 管理需要别导入到一切 GUI 函数中#### 用法要使用 context 需要使用如下函数初始化`nk_init_default`, `nk_init_fixed`, `nk_init`, `nk_init_custom`.Each takes in a font handle and a specific way of handling memory. Memory controlhereby ranges from standard library to just specifying a fixed sized block of memorywhich nuklear has to manage itself from.~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cstruct nk_context ctx;nk_init_xxx(&ctx, ...);while (1) {    // [...]    nk_clear(&ctx);}nk_free(&ctx);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#### Reference 参考函数            | 描述--------------------|-------------------------------------------------------__nk_init_default__ | 使用标准库内存函数初始化 context (malloc,free)__nk_init_fixed__   | 适用固定大小的内存块初始化 context__nk_init__         | Initializes context with memory allocator callbacks for alloc and free__nk_init_custom__  | Initializes context from two buffers. One for draw commands the other for window/panel/table allocations__nk_clear__        | 在当前帧的最后调用来初始化和准备下一帧__nk_free__         | 关闭和释放这个 context 所有的内存__nk_set_user_data__| Utility function to pass user data to draw command#### nk_init_defaultInitializes a `nk_context` struct with a default standard library allocator.Should be used if you don't want to be bothered with memory management in nuklear.~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cint nk_init_default(struct nk_context *ctx, const struct nk_user_font *font);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|---------------------------------------------------------------__ctx__     | Must point to an either stack or heap allocated `nk_context` struct__font__    | Must point to a previously initialized font handle for more info look at font documentationReturns either `false(0)` on failure or `true(1)` on success.#### nk_init_fixedInitializes a `nk_context` struct from single fixed size memory blockShould be used if you want complete control over nuklear's memory management.Especially recommended for system with little memory or systems with virtual memory.For the later case you can just allocate for example 16MB of virtual memoryand only the required amount of memory will actually be committed.~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cint nk_init_fixed(struct nk_context *ctx, void *memory, nk_size size, const struct nk_user_font *font);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!!! Warning    make sure the passed memory block is aligned correctly for `nk_draw_commands`.参数   | 描述------------|--------------------------------------------------------------__ctx__     | Must point to an either stack or heap allocated `nk_context` struct__memory__  | Must point to a previously allocated memory block__size__    | Must contain the total size of __memory____font__    | Must point to a previously initialized font handle for more info look at font documentationReturns either `false(0)` on failure or `true(1)` on success.#### nk_initInitializes a `nk_context` struct with memory allocation callbacks for nuklear to allocatememory from. Used internally for `nk_init_default` and provides a kitchen sink allocationinterface to nuklear. Can be useful for cases like monitoring memory consumption.~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cint nk_init(struct nk_context *ctx, struct nk_allocator *alloc, const struct nk_user_font *font);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|---------------------------------------------------------------__ctx__     | Must point to an either stack or heap allocated `nk_context` struct__alloc__   | Must point to a previously allocated memory allocator__font__    | Must point to a previously initialized font handle for more info look at font documentationReturns either `false(0)` on failure or `true(1)` on success.#### nk_init_customInitializes a `nk_context` struct from two different either fixed or growingbuffers. The first buffer is for allocating draw commands while the second buffer isused for allocating windows, panels and state tables.~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cint nk_init_custom(struct nk_context *ctx, struct nk_buffer *cmds, struct nk_buffer *pool, const struct nk_user_font *font);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|---------------------------------------------------------------__ctx__     | Must point to an either stack or heap allocated `nk_context` struct__cmds__    | Must point to a previously initialized memory buffer either fixed or dynamic to store draw commands into__pool__    | Must point to a previously initialized memory buffer either fixed or dynamic to store windows, panels and tables__font__    | Must point to a previously initialized font handle for more info look at font documentationReturns either `false(0)` on failure or `true(1)` on success.#### nk_clearResets the context state at the end of the frame. This includes mostlygarbage collector tasks like removing windows or table not called and thereforeused anymore.~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cvoid nk_clear(struct nk_context *ctx);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to a previously initialized `nk_context` struct#### nk_freeFrees all memory allocated by nuklear. Not needed if context wasinitialized with `nk_init_fixed`.~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cvoid nk_free(struct nk_context *ctx);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to a previously initialized `nk_context` struct#### nk_set_user_dataSets the currently passed userdata passed down into each draw command.~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cvoid nk_set_user_data(struct nk_context *ctx, nk_handle data);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|--------------------------------------------------------------__ctx__     | Must point to a previously initialized `nk_context` struct__data__    | Handle with either pointer or index to be passed into every draw commands### InputThe input API 负责保持当前由鼠标、按键和文本输入所组成的输入状态。nuklear 并没有直接操作窗口句柄或是系统所有输入状态都必须由特定于平台的代码提供的。 This in one hand expects more work from the user and complicates usage but on the other hand provides simple abstraction over a big number of platforms, libraries and other already provided 函数ality.~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cnk_input_begin(&ctx);while (GetEvent(&evt)) {    if (evt.type == MOUSE_MOVE)        nk_input_motion(&ctx, evt.motion.x, evt.motion.y);    else if (evt.type == [...]) {        // [...]    }} nk_input_end(&ctx);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#### 用法输入需要首先调用 `nk_input_begin` 来更新内部状态，如计算鼠标位置和按钮状态转换。在 `nk_input_begin` 把所有输入状态准备好后，This includes所有的包括鼠标的移动和滚动，鼠标按钮和键盘的按下和释放，文本输入等，基于事件或基于状态的 输入处理API 都可以被使用了。最后在使用完需要的输入状态后调用 `nk_input_end` 结束输入过程。~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cstruct nk_context ctx;nk_init_xxx(&ctx, ...);while (1) {    Event evt;    nk_input_begin(&ctx);    while (GetEvent(&evt)) {        if (evt.type == MOUSE_MOVE)            nk_input_motion(&ctx, evt.motion.x, evt.motion.y);        else if (evt.type == [...]) {            // [...]        }    }    nk_input_end(&ctx);    // [...]    nk_clear(&ctx);} nk_free(&ctx);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#### Reference 参考函数            | 描述--------------------|-------------------------------------------------------__nk_input_begin__  | 开始建立 Begins the input mirroring process. Needs to be called before all other `nk_input_xxx` calls__nk_input_motion__ | 鼠标光标位置__nk_input_key__    | 键的按压或释放__nk_input_button__ | 鼠标按钮的按压或释放__nk_input_scroll__ | 鼠标滚轮滚动值__nk_input_char__   | 将单个 ASCII 字符添加到内部文本缓冲区中__nk_input_glyph__  | 将单个多字节UTF-8字符添加到内部文本缓冲区中__nk_input_unicode__| 将单个 Unicode Rune 添加到内部文本缓冲区中__nk_input_end__    | 结束建立 Ends the input mirroring process by calculating state changes. Don't call any `nk_input_xxx` 函数 referenced above after this call#### nk_input_beginBegins the input mirroring process by resetting text, scrollmouse previous mouse position and movement as well as key state transitions,~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cvoid nk_input_begin(struct nk_context*);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to a previously initialized `nk_context` struct#### nk_input_motionMirrors current mouse position to nuklear~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cvoid nk_input_motion(struct nk_context *ctx, int x, int y);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to a previously initialized `nk_context` struct__x__       | Must hold an integer describing the current mouse cursor x-position__y__       | Must hold an integer describing the current mouse cursor y-position#### nk_input_keyMirrors state of a specific key to nuklear~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cvoid nk_input_key(struct nk_context*, enum nk_keys key, int down);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to a previously initialized `nk_context` struct__key__     | Must be any value specified in enum `nk_keys` that needs to be mirrored__down__    | Must be 0 for key is up and 1 for key is down#### nk_input_buttonMirrors the state of a specific mouse button to nuklear~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cvoid nk_input_button(struct nk_context *ctx, enum nk_buttons btn, int x, int y, int down);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to a previously initialized `nk_context` struct__btn__     | Must be any value specified in enum `nk_buttons` that needs to be mirrored__x__       | Must contain an integer describing mouse cursor x-position on click up/down__y__       | Must contain an integer describing mouse cursor y-position on click up/down__down__    | Must be 0 for key is up and 1 for key is down#### nk_input_scrollCopies the last mouse scroll value to nuklear. Is generallya scroll value. So does not have to come from mouse and could also originate~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cvoid nk_input_scroll(struct nk_context *ctx, struct nk_vec2 val);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to a previously initialized `nk_context` struct__val__     | vector with both X- as well as Y-scroll value#### nk_input_charCopies a single ASCII character into an internal text bufferThis is basically a helper 函数 to quickly push ASCII characters intonuklear.!!! Note    Stores up to NK_INPUT_MAX bytes between `nk_input_begin` and `nk_input_end`.~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cvoid nk_input_char(struct nk_context *ctx, char c);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to a previously initialized `nk_context` struct__c__       | Must be a single ASCII character preferable one that can be printed#### nk_input_glyphConverts an encoded unicode rune into UTF-8 and copies the result into aninternal text buffer.!!! Note    Stores up to NK_INPUT_MAX bytes between `nk_input_begin` and `nk_input_end`.~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cvoid nk_input_glyph(struct nk_context *ctx, const nk_glyph g);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to a previously initialized `nk_context` struct__g__       | UTF-32 unicode codepoint#### nk_input_unicodeConverts a unicode rune into UTF-8 and copies the resultinto an internal text buffer.!!! Note    Stores up to NK_INPUT_MAX bytes between `nk_input_begin` and `nk_input_end`.~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cvoid nk_input_unicode(struct nk_context*, nk_rune rune);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to a previously initialized `nk_context` struct__rune__    | UTF-32 unicode codepoint#### nk_input_endEnd the input mirroring process by resetting mouse grabbingstate to ensure the mouse cursor is not grabbed indefinitely.///~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cvoid nk_input_end(struct nk_context *ctx);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to a previously initialized `nk_context` struct### Drawing这个库被设计为推给后端绘制所以它不会直接在屏幕上绘制任何图形. 而是绘制形状、小部件等。这会缓冲进内存并组成命令队列。每一帧会有一个带有绘制命令的命令缓冲区，提供给后端这些绘制命令需要用户在他们自己的后端绘制中实现之后，命令缓冲区需要被清除，并且一个新的可以启动的帧。It is probably important to note that the command buffer is the maindrawing API and the optional vertex buffer API only takes this format andconverts it into a hardware accessible format.#### Usage 用法为了绘制每一帧的命令队列，你需要你自己的渲染器后端需要能绘制一些2D元素这至少包括 填充(filled) 和 绘制 矩形、圆形、文本、线、三角形 和 scissors.只要符合这个标准，用户就可以遍历每个绘图命令并且像这样描述每一个函数:~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cconst struct nk_command *cmd= 0;nk_foreach(cmd, &ctx) {    switch (cmd->type) {    case NK_COMMAND_LINE:        your_draw_line_function(...)        break;    case NK_COMMAND_RECT        your_draw_rect_function(...)        break;    case //...:        //[...]    }}~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~在程序中绘制需要在输入(input)之后执行并且在 `nk_clear` 释放之前绘制~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cstruct nk_context ctx;nk_init_xxx(&ctx, ...);while (1) {    Event evt;    nk_input_begin(&ctx);    while (GetEvent(&evt)) {        if (evt.type == MOUSE_MOVE)            nk_input_motion(&ctx, evt.motion.x, evt.motion.y);        else if (evt.type == [...]) {            [...]        }    }    nk_input_end(&ctx);    //    // [...]    //    const struct nk_command *cmd = 0;    nk_foreach(cmd, &ctx) {    switch (cmd->type) {    case NK_COMMAND_LINE:        your_draw_line_function(...)        break;    case NK_COMMAND_RECT        your_draw_rect_function(...)        break;    case ...:        // [...]    }    nk_clear(&ctx);}nk_free(&ctx);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~You probably noticed that you have to draw all of the UI each frame which isquite wasteful. While the actual UI updating loop is quite fast renderingwithout actually needing it is not. So there are multiple things you could do.First is only update on input. This of course is only an option if yourapplication only depends on the UI and does not require any outside calculations.If you actually only update on input make sure to update the UI two times eachframe and call `nk_clear` directly after the first pass and only draw inthe second pass. In addition it is recommended to also add additional timersto make sure the UI is not drawn more than a fixed number of frames per second.~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cstruct nk_context ctx;nk_init_xxx(&ctx, ...);while (1) {    // [...wait for input ]    // [...do two UI passes ...]    do_ui(...)    nk_clear(&ctx);    do_ui(...)    //    // draw    const struct nk_command *cmd = 0;    nk_foreach(cmd, &ctx) {    switch (cmd->type) {    case NK_COMMAND_LINE:        your_draw_line_函数(...)        break;    case NK_COMMAND_RECT        your_draw_rect_函数(...)        break;    case ...:        //[...]    }    nk_clear(&ctx);}nk_free(&ctx);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~The second probably more applicable trick is to only draw if anything changed.It is not really useful for applications with continuous draw loop butquite useful for desktop applications. To actually get nuklear to onlydraw on changes you first have to define `NK_ZERO_COMMAND_MEMORY` andallocate a memory buffer that will store each unique drawing output.After each frame you compare the draw command memory inside the librarywith your allocated buffer by memcmp. If memcmp detects differencesyou have to copy the command buffer into the allocated bufferand then draw like usual (this example uses fixed memory but you coulduse dynamically allocated memory).~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c//[... other defines ...]#define NK_ZERO_COMMAND_MEMORY#include "nuklear.h"//// setup contextstruct nk_context ctx;void *last = calloc(1,64*1024);void *buf = calloc(1,64*1024);nk_init_fixed(&ctx, buf, 64*1024);//// loopwhile (1) {    // [...input...]    // [...ui...]    void *cmds = nk_buffer_memory(&ctx.memory);    if (memcmp(cmds, last, ctx.memory.allocated)) {        memcpy(last,cmds,ctx.memory.allocated);        const struct nk_command *cmd = 0;        nk_foreach(cmd, &ctx) {            switch (cmd->type) {            case NK_COMMAND_LINE:                your_draw_line_函数(...)                break;            case NK_COMMAND_RECT                your_draw_rect_函数(...)                break;            case ...:                // [...]            }        }    }    nk_clear(&ctx);}nk_free(&ctx);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Finally while using draw commands makes sense for higher abstracted platforms likeX11 and Win32 or drawing libraries it is often desirable to use graphicshardware directly. Therefore it is possible to just define`NK_INCLUDE_VERTEX_BUFFER_OUTPUT` which includes optional vertex output.To access the vertex output you first have to convert all draw commands intovertexes by calling `nk_convert` which takes in your preferred vertex format.After successfully converting all draw commands just iterate over and execute allvertex draw commands:~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c// fill configurationstruct nk_convert_config cfg = {};static const struct nk_draw_vertex_layout_element vertex_layout[] = {    {NK_VERTEX_POSITION, NK_FORMAT_FLOAT, NK_OFFSETOF(struct your_vertex, pos)},    {NK_VERTEX_TEXCOORD, NK_FORMAT_FLOAT, NK_OFFSETOF(struct your_vertex, uv)},    {NK_VERTEX_COLOR, NK_FORMAT_R8G8B8A8, NK_OFFSETOF(struct your_vertex, col)},    {NK_VERTEX_LAYOUT_END}};cfg.shape_AA = NK_ANTI_ALIASING_ON;cfg.line_AA = NK_ANTI_ALIASING_ON;cfg.vertex_layout = vertex_layout;cfg.vertex_size = sizeof(struct your_vertex);cfg.vertex_alignment = NK_ALIGNOF(struct your_vertex);cfg.circle_segment_count = 22;cfg.curve_segment_count = 22;cfg.arc_segment_count = 22;cfg.global_alpha = 1.0f;cfg.null = dev->null;//// setup buffers and convertstruct nk_buffer cmds, verts, idx;nk_buffer_init_default(&cmds);nk_buffer_init_default(&verts);nk_buffer_init_default(&idx);nk_convert(&ctx, &cmds, &verts, &idx, &cfg);//// drawnk_draw_foreach(cmd, &ctx, &cmds) {if (!cmd->elem_count) continue;    //[...]}nk_buffer_free(&cms);nk_buffer_free(&verts);nk_buffer_free(&idx);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#### Reference 参考函数            | 描述--------------------|-------------------------------------------------------__nk__begin__       | 返回要绘制的绘制命令列表中的第一个绘制命令__nk__next__        | 将绘制命令迭代器递增到绘制命令列表中的下一个命令__nk_foreach__      | 遍历绘制命令列表中的每个绘图命令__nk_convert__      | Converts from the abstract draw commands list into a hardware accessible vertex format__nk_draw_begin__   | 返回要执行的顶点绘制列表中的第一个顶点命令？？__nk__draw_next__   | 将顶点命令迭代器递增到顶点命令列表中的下一个命令__nk__draw_end__    | 返回顶点绘制列表的末尾__nk_draw_foreach__ | 遍历顶点绘制列表中的每个顶点绘制命令#### nk__beginReturns a draw command list iterator to iterate all drawcommands accumulated over one frame.~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cconst struct nk_command* nk__begin(struct nk_context*);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | must point to an previously initialized `nk_context` struct at the end of a frameReturns draw command pointer pointing to the first command inside the draw command list#### nk__nextReturns a draw command list iterator to iterate all draw~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cconst struct nk_command* nk__next(struct nk_context*, const struct nk_command*);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to an previously initialized `nk_context` struct at the end of a frame__cmd__     | Must point to an previously a draw command either returned by `nk__begin` or `nk__next`Returns draw command pointer pointing to the next command inside the draw command list#### nk_foreachIterates over each draw command inside the context draw command list~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c#define nk_foreach(c, ctx)~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to an previously initialized `nk_context` struct at the end of a frame__cmd__     | Command pointer initialized to NULLReturns draw command pointer pointing to the next command inside the draw command list#### nk_convertConverts all internal draw commands into vertex draw commands and fillsthree buffers with vertexes, vertex draw commands and vertex indices. The vertex formatas well as some other configuration values have to be configured by filling out a`nk_convert_config` struct.~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cnk_flags nk_convert(struct nk_context *ctx, struct nk_buffer *cmds,~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to an previously initialized `nk_context` struct at the end of a frame__cmds__    | Must point to a previously initialized buffer to hold converted vertex draw commands__vertices__| Must point to a previously initialized buffer to hold all produced vertices__elements__| Must point to a previously initialized buffer to hold all produced vertex indices__config__  | Must point to a filled out `nk_config` struct to configure the conversion processReturns one of enum nk_convert_result error codes参数                       | 描述--------------------------------|-----------------------------------------------------------NK_CONVERT_SUCCESS              | Signals a successful draw command to vertex buffer conversionNK_CONVERT_INVALID_PARAM        | An invalid argument was passed in the 函数 callNK_CONVERT_COMMAND_BUFFER_FULL  | The provided buffer for storing draw commands is full or failed to allocate more memoryNK_CONVERT_VERTEX_BUFFER_FULL   | The provided buffer for storing vertices is full or failed to allocate more memoryNK_CONVERT_ELEMENT_BUFFER_FULL  | The provided buffer for storing indicies is full or failed to allocate more memory#### nk__draw_beginReturns a draw vertex command buffer iterator to iterate each the vertex draw command buffer~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cconst struct nk_draw_command* nk__draw_begin(const struct nk_context*, const struct nk_buffer*);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to an previously initialized `nk_context` struct at the end of a frame__buf__     | Must point to an previously by `nk_convert` filled out vertex draw command bufferReturns vertex draw command pointer pointing to the first command inside the vertex draw command buffer#### nk__draw_endReturns the vertex draw command at the end of the vertex draw command buffer~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cconst struct nk_draw_command* nk__draw_end(const struct nk_context *ctx, const struct nk_buffer *buf);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to an previously initialized `nk_context` struct at the end of a frame__buf__     | Must point to an previously by `nk_convert` filled out vertex draw command bufferReturns vertex draw command pointer pointing to the end of the last vertex draw command inside the vertex draw command buffer#### nk__draw_nextIncrements the vertex draw command buffer iterator~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cconst struct nk_draw_command* nk__draw_next(const struct nk_draw_command*, const struct nk_buffer*, const struct nk_context*);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__cmd__     | Must point to an previously either by `nk__draw_begin` or `nk__draw_next` returned vertex draw command__buf__     | Must point to an previously by `nk_convert` filled out vertex draw command buffer__ctx__     | Must point to an previously initialized `nk_context` struct at the end of a frameReturns vertex draw command pointer pointing to the end of the last vertex draw command inside the vertex draw command buffer#### nk_draw_foreachIterates over each vertex draw command inside a vertex draw command buffer~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c#define nk_draw_foreach(cmd,ctx, b)~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__cmd__     | `nk_draw_command`iterator set to NULL__buf__     | Must point to an previously by `nk_convert` filled out vertex draw command buffer__ctx__     | Must point to an previously initialized `nk_context` struct at the end of a frame### WINDOW 窗口Windows 是 nuklear 的主要持久状态，它的生命周期取决于在每一帧中被调用，所有的小部件都只能加到函数 `nk_begin_xxx` 和 `nk_end` 之间。每一个窗口都保持一个持久状态包括 位置、大小、标志(flags)、状态表(state tables)，和 一些垃圾回收内部持久小部件状态(some garbage collected internal persistent widget state)。每个窗口被链接到一个窗口堆栈列表中，该列表决定绘图和重叠顺序。最顶层窗口是当前活动窗口。用户点击会自动更改堆栈内的窗口位置也可以调用 `nk_window_focus` 。默认情况下窗口是可见的，除非显式地用标志去定义。`NK_WINDOW_HIDDEN`      用户单击带有标志的Windows上的关闭按钮`NK_WINDOW_CLOSABLE`    窗口显式地通过调用隐藏`nk_window_show`        调用 `nk_window_close` 显式关闭和销毁窗口#### Usage 用法创建并保持一个 窗口(window) 需要调用两个 `nk_begin_xxx` 中的一个并在最后调用 `nk_end`。建议检查一下 `nk_begin_xxx` 的返回值`nk_begin_xxx` 不能嵌套~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cif (nk_begin_xxx(...) {    // [... widgets ...]}nk_end(ctx);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~在窗口和小部件的调用需要在输入处理之后和绘制到屏幕之前进行。不这样做可能导致更高的延迟或最坏的无效行为。此外请确保在帧的末尾调用 `nk_clear` 。虽然nuklear的默认平台后端已经为您调用 `nk_clear` 。但是如果自己的后端而不调用 `nk_clear` 可能会导致糟糕的未定义行为。~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cstruct nk_context ctx;nk_init_xxx(&ctx, ...);while (1) {    Event evt;    nk_input_begin(&ctx);    while (GetEvent(&evt)) {        if (evt.type == MOUSE_MOVE)            nk_input_motion(&ctx, evt.motion.x, evt.motion.y);        else if (evt.type == [...]) {            nk_input_xxx(...);        }    }    nk_input_end(&ctx);    if (nk_begin_xxx(...) {        //[...]    }    nk_end(ctx);    const struct nk_command *cmd = 0;    nk_foreach(cmd, &ctx) {    case NK_COMMAND_LINE:        your_draw_line_函数(...)        break;    case NK_COMMAND_RECT        your_draw_rect_函数(...)        break;    case //...:        //[...]    }    nk_clear(&ctx);}nk_free(&ctx);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#### Reference 参考函数                            | 描述------------------------------------|----------------------------------------nk_begin                            | 建立一个新窗口，除非想隐藏它，否则在调用每一帧都要调用nk_begin_titled                     | 分离的标题和标识符的窗口，允许出现具有相同名称但不同标题的多个窗口nk_end                              | 需要在窗口构建结束时调用以进行缩放，滚动条和一般清理工作nk_window_find                      | 通过名字查找并返回窗口nk_window_get_bounds                | 返回当前处理的窗口的位置和大小矩阵。nk_window_get_position              | 返回当前处理的窗口的位置nk_window_get_size                  | 返回当前处理的窗口的宽度和高度的大小nk_window_get_width                 | 返回当前处理的窗口的宽度nk_window_get_height                | 返回当前处理的窗口的高度nk_window_get_panel                 | Returns the underlying panel which contains all processing state of the current windownk_window_get_content_region        | Returns the position and size of the currently visible and non-clipped space inside the currently processed windownk_window_get_content_region_min    | Returns the upper rectangle position of the currently visible and non-clipped space inside the currently processed windownk_window_get_content_region_max    | Returns the upper rectangle position of the currently visible and non-clipped space inside the currently processed windownk_window_get_content_region_size   | Returns the size of the currently visible and non-clipped space inside the currently processed windownk_window_get_canvas                | 返回绘图命令缓冲区。可以用来绘制自定义小部件nk_window_has_focus                 | 返回当前正在处理的窗口当前是否处于活动状态nk_window_is_collapsed              | 返回具有给定名称的窗口当前是否已最小化（折叠）nk_window_is_closed                 | 返回当前处理的窗口是否关闭nk_window_is_hidden                 | 返回当前处理的窗口是否隐藏nk_window_is_active                 | 与 nk_window_has_focus 相同nk_window_is_hovered                | 返回当前正在处理的窗口是否是现在鼠标悬停着的窗口nk_window_is_any_hovered            | Return if any window currently hoverednk_item_is_any_active               | Returns if any window or widgets is currently hovered or activenk_window_set_bounds                | 设置当前处理窗口的位置和大小nk_window_set_position              | 设置当前处理窗口的位置nk_window_set_size                  | 设置当前处理窗口的大小nk_window_set_focus                 | 将当前处理的窗口设置为活动窗口nk_window_close                     | 将给定的窗口名称的窗口关闭 which deletes the window at the end of the framenk_window_collapse                  | 将给定的窗口名称的窗口折叠nk_window_collapse_if               | 如果满足给定的条件，则将给定的窗口名称的窗口折叠nk_window_show                      | 隐藏一个窗口（无论它现在是显示还是隐藏）nk_window_show_if                   | 如果满足给定的条件，则隐藏一个窗口#### nk_panel_flags 标记标记                        | 描述----------------------------|----------------------------------------NK_WINDOW_BORDER            | 在窗口周围绘制一个边框NK_WINDOW_MOVABLE           | 窗口可以移动NK_WINDOW_SCALABLE          | 窗口可以缩放NK_WINDOW_CLOSABLE          | 在标题中添加关闭的按钮NK_WINDOW_MINIMIZABLE       | 在标题中添加最小化的按钮NK_WINDOW_NO_SCROLLBAR      | 从窗口中移除滚动条NK_WINDOW_TITLE             | 在窗口的顶部强制显示标题NK_WINDOW_SCROLL_AUTO_HIDE  | 如果没有用户交互，则自动隐藏窗口滚动条：还需要在 `nk_context` 中设置一个计数器NK_WINDOW_BACKGROUND        | 始终保持窗口在后台NK_WINDOW_SCALE_LEFT        | 将窗口缩放器放在左下角而不是右下角NK_WINDOW_NO_INPUT          | 阻止缩放，移动或聚焦窗口#### nk_collapse_states状态           | 描述----------------|-----------------------------------------------------------__NK_MINIMIZED__| UI section is collased and not visibile until maximized__NK_MAXIMIZED__| UI section is extended and visibile until minimized#### nk_beginStarts a new window; needs to be called every frame for everywindow (unless hidden) or otherwise the window gets removed~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cint nk_begin(struct nk_context *ctx, const char *title, struct nk_rect bounds, nk_flags flags);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to an previously initialized `nk_context` struct__title__   | Window title and identifier. Needs to be persistent over frames to identify the window__bounds__  | Initial position and window size. However if you do not define `NK_WINDOW_SCALABLE` or `NK_WINDOW_MOVABLE` you can set window position and size every frame__flags__   | Window flags defined in the nk_panel_flags section with a number of different window behaviorsReturns `true(1)` if the window can be filled up with widgets from this pointuntil `nk_end` or `false(0)` otherwise for example if minimized#### nk_begin_titledExtended window start with separated title and identifier to allow multiplewindows with same name but not title~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cint nk_begin_titled(struct nk_context *ctx, const char *name, const char *title, struct nk_rect bounds, nk_flags flags);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to an previously initialized `nk_context` struct__name__    | Window identifier. Needs to be persistent over frames to identify the window__title__   | Window title displayed inside header if flag `NK_WINDOW_TITLE` or either `NK_WINDOW_CLOSABLE` or `NK_WINDOW_MINIMIZED` was set__bounds__  | Initial position and window size. However if you do not define `NK_WINDOW_SCALABLE` or `NK_WINDOW_MOVABLE` you can set window position and size every frame__flags__   | Window flags defined in the nk_panel_flags section with a number of different window behaviorsReturns `true(1)` if the window can be filled up with widgets from this pointuntil `nk_end` or `false(0)` otherwise for example if minimized#### nk_endNeeds to be called at the end of the window building process to process scaling, scrollbars and general cleanup.All widget calls after this 函数s will result in asserts or no state changes~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cvoid nk_end(struct nk_context *ctx);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to an previously initialized `nk_context` struct#### nk_window_findFinds and returns a window from passed name~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cvoid nk_end(struct nk_context *ctx);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to an previously initialized `nk_context` struct__name__    | Window identifierReturns a `nk_window` struct pointing to the identified window or NULL ifno window with given name was found#### nk_window_get_boundsReturns a rectangle with screen position and size of the currently processed window!!! WARNING    Only call this function between calls `nk_begin_xxx` and `nk_end`~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cstruct nk_rect nk_window_get_bounds(const struct nk_context *ctx);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to an previously initialized `nk_context` structReturns a `nk_rect` struct with window upper left window position and size#### nk_window_get_boundsReturns the position of the currently processed window.!!! WARNING    Only call this function between calls `nk_begin_xxx` and `nk_end`~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cstruct nk_vec2 nk_window_get_position(const struct nk_context *ctx);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to an previously initialized `nk_context` structReturns a `nk_vec2` struct with window upper left position#### nk_window_get_sizeReturns the size with width and height of the currently processed window.!!! WARNING    Only call this function between calls `nk_begin_xxx` and `nk_end`~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cstruct nk_vec2 nk_window_get_size(const struct nk_context *ctx);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to an previously initialized `nk_context` structReturns a `nk_vec2` struct with window width and height#### nk_window_get_widthReturns the width of the currently processed window.!!! WARNING    Only call this function between calls `nk_begin_xxx` and `nk_end`~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cfloat nk_window_get_width(const struct nk_context *ctx);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to an previously initialized `nk_context` structReturns the current window width#### nk_window_get_heightReturns the height of the currently processed window.!!! WARNING    Only call this function between calls `nk_begin_xxx` and `nk_end`~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cfloat nk_window_get_height(const struct nk_context *ctx);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to an previously initialized `nk_context` structReturns the current window height#### nk_window_get_panelReturns the underlying panel which contains all processing state of the current window.!!! WARNING    Only call this 函数 between calls `nk_begin_xxx` and `nk_end`!!! WARNING    Do not keep the returned panel pointer around it is only valid until `nk_end`~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cstruct nk_panel* nk_window_get_panel(struct nk_context *ctx);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to an previously initialized `nk_context` structReturns a pointer to window internal `nk_panel` state.#### nk_window_get_content_regionReturns the position and size of the currently visible and non-clipped spaceinside the currently processed window.!!! WARNING    Only call this 函数 between calls `nk_begin_xxx` and `nk_end`~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cstruct nk_rect nk_window_get_content_region(struct nk_context *ctx);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to an previously initialized `nk_context` structReturns `nk_rect` struct with screen position and size (no scrollbar offset)of the visible space inside the current window#### nk_window_get_content_region_minReturns the upper left position of the currently visible and non-clippedspace inside the currently processed window.!!! WARNING    Only call this 函数 between calls `nk_begin_xxx` and `nk_end`~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cstruct nk_vec2 nk_window_get_content_region_min(struct nk_context *ctx);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to an previously initialized `nk_context` structreturns `nk_vec2` struct with  upper left screen position (no scrollbar offset)of the visible space inside the current window#### nk_window_get_content_region_maxReturns the lower right screen position of the currently visible andnon-clipped space inside the currently processed window.!!! WARNING    Only call this 函数 between calls `nk_begin_xxx` and `nk_end`~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cstruct nk_vec2 nk_window_get_content_region_max(struct nk_context *ctx);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to an previously initialized `nk_context` structReturns `nk_vec2` struct with lower right screen position (no scrollbar offset)of the visible space inside the current window#### nk_window_get_content_region_sizeReturns the size of the currently visible and non-clipped space inside thecurrently processed window!!! WARNING    Only call this 函数 between calls `nk_begin_xxx` and `nk_end`~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cstruct nk_vec2 nk_window_get_content_region_size(struct nk_context *ctx);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to an previously initialized `nk_context` structReturns `nk_vec2` struct with size the visible space inside the current window#### nk_window_get_canvasReturns the draw command buffer. Can be used to draw custom widgets!!! WARNING    Only call this 函数 between calls `nk_begin_xxx` and `nk_end`!!! WARNING    Do not keep the returned command buffer pointer around it is only valid until `nk_end`~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cstruct nk_command_buffer* nk_window_get_canvas(struct nk_context *ctx);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to an previously initialized `nk_context` structReturns a pointer to window internal `nk_command_buffer` struct used asdrawing canvas. Can be used to do custom drawing.#### nk_window_has_focusReturns if the currently processed window is currently active!!! WARNING    Only call this 函数 between calls `nk_begin_xxx` and `nk_end`~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cint nk_window_has_focus(const struct nk_context *ctx);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to an previously initialized `nk_context` structReturns `false(0)` if current window is not active or `true(1)` if it is#### nk_window_is_hoveredReturn if the current window is being hovered!!! WARNING    Only call this 函数 between calls `nk_begin_xxx` and `nk_end`~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cint nk_window_is_hovered(struct nk_context *ctx);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to an previously initialized `nk_context` structReturns `true(1)` if current window is hovered or `false(0)` otherwise#### nk_window_is_collapsedReturns if the window with given name is currently minimized/collapsed~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cint nk_window_is_collapsed(struct nk_context *ctx, const char *name);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to an previously initialized `nk_context` struct__name__    | Identifier of window you want to check if it is collapsedReturns `true(1)` if current window is minimized and `false(0)` if window notfound or is not minimized#### nk_window_is_closedReturns if the window with given name was closed by calling `nk_close`~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cint nk_window_is_closed(struct nk_context *ctx, const char *name);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to an previously initialized `nk_context` struct__name__    | Identifier of window you want to check if it is closedReturns `true(1)` if current window was closed or `false(0)` window not found or not closed#### nk_window_is_hiddenReturns if the window with given name is hidden~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cint nk_window_is_hidden(struct nk_context *ctx, const char *name);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to an previously initialized `nk_context` struct__name__    | Identifier of window you want to check if it is hiddenReturns `true(1)` if current window is hidden or `false(0)` window not found or visible#### nk_window_is_activeSame as nk_window_has_focus for some reason~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cint nk_window_is_active(struct nk_context *ctx, const char *name);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to an previously initialized `nk_context` struct__name__    | Identifier of window you want to check if it is activeReturns `true(1)` if current window is active or `false(0)` window not found or not active#### nk_window_is_any_hoveredReturns if the any window is being hovered~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cint nk_window_is_any_hovered(struct nk_context*);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to an previously initialized `nk_context` structReturns `true(1)` if any window is hovered or `false(0)` otherwise#### nk_item_is_any_activeReturns if the any window is being hovered or any widget is currently active.Can be used to decide if input should be processed by UI or your specific input handling.Example could be UI and 3D camera to move inside a 3D space.~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cint nk_item_is_any_active(struct nk_context*);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to an previously initialized `nk_context` structReturns `true(1)` if any window is hovered or any item is active or `false(0)` otherwise#### nk_window_set_boundsUpdates position and size of window with passed in name~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cvoid nk_window_set_bounds(struct nk_context*, const char *name, struct nk_rect bounds);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to an previously initialized `nk_context` struct__name__    | Identifier of the window to modify both position and size__bounds__  | Must point to a `nk_rect` struct with the new position and size#### nk_window_set_positionUpdates position of window with passed name~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cvoid nk_window_set_position(struct nk_context*, const char *name, struct nk_vec2 pos);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to an previously initialized `nk_context` struct__name__    | Identifier of the window to modify both position__pos__     | Must point to a `nk_vec2` struct with the new position#### nk_window_set_sizeUpdates size of window with passed in name~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cvoid nk_window_set_size(struct nk_context*, const char *name, struct nk_vec2);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to an previously initialized `nk_context` struct__name__    | Identifier of the window to modify both window size__size__    | Must point to a `nk_vec2` struct with new window size#### nk_window_set_focusSets the window with given name as active~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cvoid nk_window_set_focus(struct nk_context*, const char *name);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to an previously initialized `nk_context` struct__name__    | Identifier of the window to set focus on#### nk_window_closeCloses a window and marks it for being freed at the end of the frame~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cvoid nk_window_close(struct nk_context *ctx, const char *name);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to an previously initialized `nk_context` struct__name__    | Identifier of the window to close#### nk_window_collapseUpdates collapse state of a window with given name~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cvoid nk_window_collapse(struct nk_context*, const char *name, enum nk_collapse_states state);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to an previously initialized `nk_context` struct__name__    | Identifier of the window to close__state__   | value out of nk_collapse_states section#### nk_window_collapse_ifUpdates collapse state of a window with given name if given condition is met~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cvoid nk_window_collapse_if(struct nk_context*, const char *name, enum nk_collapse_states, int cond);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to an previously initialized `nk_context` struct__name__    | Identifier of the window to either collapse or maximize__state__   | value out of nk_collapse_states section the window should be put into__cond__    | condition that has to be met to actually commit the collapse state change#### nk_window_showupdates visibility state of a window with given name~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cvoid nk_window_show(struct nk_context*, const char *name, enum nk_show_states);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to an previously initialized `nk_context` struct__name__    | Identifier of the window to either collapse or maximize__state__   | state with either visible or hidden to modify the window with#### nk_window_show_ifUpdates visibility state of a window with given name if a given condition is met~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cvoid nk_window_show_if(struct nk_context*, const char *name, enum nk_show_states, int cond);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to an previously initialized `nk_context` struct__name__    | Identifier of the window to either hide or show__state__   | state with either visible or hidden to modify the window with__cond__    | condition that has to be met to actually commit the visbility state change### LayoutingLayouting 描述了小部件放置在窗口中的位置和大小。在这里，有五个不同的API用于布局，每个API在控制和易用性之间都有不同的权衡。All layouting methods in this library are based around the concept of a row.A row has a height the window content grows by and a number of columns and eachlayouting method specifies how each widget is placed inside the row.After a row has been allocated by calling a layouting 函数s and thenfilled with widgets will advance an internal pointer over the allocated row. To actually define a layout you just call the appropriate layouting 函数and each subsequent widget call will place the widget as specified. Importanthere is that if you define more widgets then columns defined inside the layout函数s it will allocate the next row without you having to make another layouting call.Biggest limitation with using all these APIs outside the `nk_layout_space_xxx` APIis that you have to define the row height for each. However the row heightoften depends on the height of the font. To fix that internally nuklear uses a minimum row height that is set to theheight plus padding of currently active font and overwrites the row heightvalue if zero. If you manually want to change the minimum row height thenuse nk_layout_set_min_row_height, and use nk_layout_reset_min_row_height toreset it back to be derived from font height. Also if you change the font in nuklear it will automatically change the minimumrow height for you and. This means if you change the font but still wanta minimum row height smaller than the font you have to repush your value. For actually more advanced UI I would even recommend using the `nk_layout_space_xxx`layouting method in combination with a cassowary constraint solver (there aresome versions on github with permissive license model) to take over all control over widgetlayouting yourself. However for quick and dirty layouting using all the other layouting函数s should be fine.#### Usage 用法1.  __nk_layout_row_dynamic__    最简单的布局函数是 `nk_layout_row_dynamic`。    它为每个小部件在行内提供相同的水平空间，并在窗口宽度变化时动态变化。    通过公式动态指定每个小部件的大小：    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c    widget_width = (window_width - padding - spacing) * (1/colum_count)    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~    Just like all other layouting APIs if you define more widget than columns this    library will allocate a new row and keep all layouting 参数s previously    defined.    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c    if (nk_begin_xxx(...) {        // first row with height: 30 composed of two widgets        nk_layout_row_dynamic(&ctx, 30, 2);        nk_widget(...);        nk_widget(...);        //        // second row with same 参数 as defined above        nk_widget(...);        nk_widget(...);        //        // third row uses 0 for height which will use auto layouting        nk_layout_row_dynamic(&ctx, 0, 2);        nk_widget(...);        nk_widget(...);    }    nk_end(...);    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~2.  __nk_layout_row_static__    Another easy layouting 函数 is `nk_layout_row_static`. It provides each    widget with same horizontal pixel width inside the row and does not grow    if the owning window scales smaller or bigger.    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c    if (nk_begin_xxx(...) {        // first row with height: 30 composed of two widgets with width: 80        nk_layout_row_static(&ctx, 30, 80, 2);        nk_widget(...);        nk_widget(...);        //        // second row with same 参数 as defined above        nk_widget(...);        nk_widget(...);        //        // third row uses 0 for height which will use auto layouting        nk_layout_row_static(&ctx, 0, 80, 2);        nk_widget(...);        nk_widget(...);    }    nk_end(...);    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~3.  __nk_layout_row_xxx__    A little bit more advanced layouting API are 函数s `nk_layout_row_begin`,    `nk_layout_row_push` and `nk_layout_row_end`. They allow to directly    specify each column pixel or window ratio in a row. It supports either    directly setting per column pixel width or widget window ratio but not    both. Furthermore it is a immediate mode API so each value is directly    pushed before calling a widget. Therefore the layout is not automatically    repeating like the last two layouting 函数s.    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c    if (nk_begin_xxx(...) {        // first row with height: 25 composed of two widgets with width 60 and 40        nk_layout_row_begin(ctx, NK_STATIC, 25, 2);        nk_layout_row_push(ctx, 60);        nk_widget(...);        nk_layout_row_push(ctx, 40);        nk_widget(...);        nk_layout_row_end(ctx);        //        // second row with height: 25 composed of two widgets with window ratio 0.25 and 0.75        nk_layout_row_begin(ctx, NK_DYNAMIC, 25, 2);        nk_layout_row_push(ctx, 0.25f);        nk_widget(...);        nk_layout_row_push(ctx, 0.75f);        nk_widget(...);        nk_layout_row_end(ctx);        //        // third row with auto generated height: composed of two widgets with window ratio 0.25 and 0.75        nk_layout_row_begin(ctx, NK_DYNAMIC, 0, 2);        nk_layout_row_push(ctx, 0.25f);        nk_widget(...);        nk_layout_row_push(ctx, 0.75f);        nk_widget(...);        nk_layout_row_end(ctx);    }    nk_end(...);    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~4.  __nk_layout_row__    The array counterpart to API nk_layout_row_xxx is the single nk_layout_row    函数s. Instead of pushing either pixel or window ratio for every widget    it allows to define it by array. The trade of for less control is that    `nk_layout_row` is automatically repeating. Otherwise the behavior is the    same.    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c    if (nk_begin_xxx(...) {        // two rows with height: 30 composed of two widgets with width 60 and 40        const float size[] = {60,40};        nk_layout_row(ctx, NK_STATIC, 30, 2, ratio);        nk_widget(...);        nk_widget(...);        nk_widget(...);        nk_widget(...);        //        // two rows with height: 30 composed of two widgets with window ratio 0.25 and 0.75        const float ratio[] = {0.25, 0.75};        nk_layout_row(ctx, NK_DYNAMIC, 30, 2, ratio);        nk_widget(...);        nk_widget(...);        nk_widget(...);        nk_widget(...);        //        // two rows with auto generated height composed of two widgets with window ratio 0.25 and 0.75        const float ratio[] = {0.25, 0.75};        nk_layout_row(ctx, NK_DYNAMIC, 30, 2, ratio);        nk_widget(...);        nk_widget(...);        nk_widget(...);        nk_widget(...);    }    nk_end(...);    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~5.  __nk_layout_row_template_xxx__    The most complex and second most flexible API is a simplified flexbox version without    line wrapping and weights for dynamic widgets. It is an immediate mode API but    unlike `nk_layout_row_xxx` it has auto repeat behavior and needs to be called    before calling the templated widgets.    The row template layout has three different per widget size specifier. The first    one is the `nk_layout_row_template_push_static`  with fixed widget pixel width.    They do not grow if the row grows and will always stay the same.    The second size specifier is `nk_layout_row_template_push_variable`    which defines a minimum widget size but it also can grow if more space is available    not taken by other widgets.    Finally there are dynamic widgets with `nk_layout_row_template_push_dynamic`    which are completely flexible and unlike variable widgets can even shrink    to zero if not enough space is provided.    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c    if (nk_begin_xxx(...) {        // two rows with height: 30 composed of three widgets        nk_layout_row_template_begin(ctx, 30);        nk_layout_row_template_push_dynamic(ctx);        nk_layout_row_template_push_variable(ctx, 80);        nk_layout_row_template_push_static(ctx, 80);        nk_layout_row_template_end(ctx);        //        // first row        nk_widget(...); // dynamic widget can go to zero if not enough space        nk_widget(...); // variable widget with min 80 pixel but can grow bigger if enough space        nk_widget(...); // static widget with fixed 80 pixel width        //        // second row same layout        nk_widget(...);        nk_widget(...);        nk_widget(...);    }    nk_end(...);    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~6.  __nk_layout_space_xxx__    Finally the most flexible API directly allows you to place widgets inside the    window. The space layout API is an immediate mode API which does not support    row auto repeat and directly sets position and size of a widget. Position    and size hereby can be either specified as ratio of allocated space or    allocated space local position and pixel size. Since this API is quite    powerful there are a number of utility 函数s to get the available space    and convert between local allocated space and screen space.    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c    if (nk_begin_xxx(...) {        // static row with height: 500 (you can set column count to INT_MAX if you don't want to be bothered)        nk_layout_space_begin(ctx, NK_STATIC, 500, INT_MAX);        nk_layout_space_push(ctx, nk_rect(0,0,150,200));        nk_widget(...);        nk_layout_space_push(ctx, nk_rect(200,200,100,200));        nk_widget(...);        nk_layout_space_end(ctx);        //        // dynamic row with height: 500 (you can set column count to INT_MAX if you don't want to be bothered)        nk_layout_space_begin(ctx, NK_DYNAMIC, 500, INT_MAX);        nk_layout_space_push(ctx, nk_rect(0.5,0.5,0.1,0.1));        nk_widget(...);        nk_layout_space_push(ctx, nk_rect(0.7,0.6,0.1,0.1));        nk_widget(...);    }    nk_end(...);    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#### Reference函数                                | 描述----------------------------------------|------------------------------------nk_layout_set_min_row_height            | Set the currently used minimum row height to a specified valuenk_layout_reset_min_row_height          | Resets the currently used minimum row height to font heightnk_layout_widget_bounds                 | Calculates current width a static layout row can fit inside a windownk_layout_ratio_from_pixel              | Utility 函数s to calculate window ratio from pixel sizenk_layout_row_dynamic                   | Current layout is divided into n same sized growing columnsnk_layout_row_static                    | Current layout is divided into n same fixed sized columnsnk_layout_row_begin                     | Starts a new row with given height and number of columnsnk_layout_row_push                      | Pushes another column with given size or window rationk_layout_row_end                       | Finished previously started rownk_layout_row                           | Specifies row columns in array as either window ratio or sizenk_layout_row_template_begin            | Begins the row template declarationnk_layout_row_template_push_dynamic     | Adds a dynamic column that dynamically grows and can go to zero if not enough spacenk_layout_row_template_push_variable    | Adds a variable column that dynamically grows but does not shrink below specified pixel widthnk_layout_row_template_push_static      | Adds a static column that does not grow and will always have the same sizenk_layout_row_template_end              | Marks the end of the row templatenk_layout_space_begin                   | Begins a new layouting space that allows to specify each widgets position and sizenk_layout_space_push                    | Pushes position and size of the next widget in own coordinate space either as pixel or rationk_layout_space_end                     | Marks the end of the layouting spacenk_layout_space_bounds                  | Callable after nk_layout_space_begin and returns total space allocatednk_layout_space_to_screen               | Converts vector from nk_layout_space coordinate space into screen spacenk_layout_space_to_local                | Converts vector from screen space into nk_layout_space coordinatesnk_layout_space_rect_to_screen          | Converts rectangle from nk_layout_space coordinate space into screen spacenk_layout_space_rect_to_local           | Converts rectangle from screen space into nk_layout_space coordinates#### nk_layout_set_min_row_heightSets the currently used minimum row height.!!! WARNING    The passed height needs to include both your preferred row height    as well as padding. No internal padding is added.~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cvoid nk_layout_set_min_row_height(struct nk_context*, float height);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`__height__  | New minimum row height to be used for auto generating the row height#### nk_layout_reset_min_row_heightReset the currently used minimum row height back to `font_height + text_padding + padding`~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cvoid nk_layout_reset_min_row_height(struct nk_context*);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`#### nk_layout_widget_boundsReturns the width of the next row allocate by one of the layouting 函数s~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cstruct nk_rect nk_layout_widget_bounds(struct nk_context*);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`Return `nk_rect` with both position and size of the next row#### nk_layout_ratio_from_pixelUtility 函数s to calculate window ratio from pixel size~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cfloat nk_layout_ratio_from_pixel(struct nk_context*, float pixel_width);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`__pixel__   | Pixel_width to convert to window ratioReturns `nk_rect` with both position and size of the next row#### nk_layout_row_dynamicSets current row layout to share horizontal spacebetween @cols number of widgets evenly. Once called all subsequent widgetcalls greater than @cols will allocate a new row with same layout.~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cvoid nk_layout_row_dynamic(struct nk_context *ctx, float height, int cols);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`__height__  | Holds height of each widget in row or zero for auto layouting__columns__ | Number of widget inside row#### nk_layout_row_dynamicSets current row layout to fill @cols number of widgetsin row with same @item_width horizontal size. Once called all subsequent widgetcalls greater than @cols will allocate a new row with same layout.~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cvoid nk_layout_row_static(struct nk_context *ctx, float height, int item_width, int cols);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`__height__  | Holds height of each widget in row or zero for auto layouting__width__   | Holds pixel width of each widget in the row__columns__ | Number of widget inside row#### nk_layout_row_beginStarts a new dynamic or fixed row with given height and columns.~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cvoid nk_layout_row_begin(struct nk_context *ctx, enum nk_layout_format fmt, float row_height, int cols);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`__fmt__     | either `NK_DYNAMIC` for window ratio or `NK_STATIC` for fixed size columns__height__  | holds height of each widget in row or zero for auto layouting__columns__ | Number of widget inside row#### nk_layout_row_pushSpecifies either window ratio or width of a single column~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cvoid nk_layout_row_push(struct nk_context*, float value);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`__value__   | either a window ratio or fixed width depending on @fmt in previous `nk_layout_row_begin` call#### nk_layout_row_endFinished previously started row~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cvoid nk_layout_row_end(struct nk_context*);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`#### nk_layout_rowSpecifies row columns in array as either window ratio or size~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cvoid nk_layout_row(struct nk_context*, enum nk_layout_format, float height, int cols, const float *ratio);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`__fmt__     | Either `NK_DYNAMIC` for window ratio or `NK_STATIC` for fixed size columns__height__  | Holds height of each widget in row or zero for auto layouting__columns__ | Number of widget inside row#### nk_layout_row_template_beginBegins the row template declaration~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cvoid nk_layout_row_template_begin(struct nk_context*, float row_height);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`__height__  | Holds height of each widget in row or zero for auto layouting#### nk_layout_row_template_push_dynamicAdds a dynamic column that dynamically grows and can go to zero if not enough space~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cvoid nk_layout_row_template_push_dynamic(struct nk_context*);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`__height__  | Holds height of each widget in row or zero for auto layouting#### nk_layout_row_template_push_variableAdds a variable column that dynamically grows but does not shrink below specified pixel width~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cvoid nk_layout_row_template_push_variable(struct nk_context*, float min_width);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`__width__   | Holds the minimum pixel width the next column must always be#### nk_layout_row_template_push_staticAdds a static column that does not grow and will always have the same size~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cvoid nk_layout_row_template_push_static(struct nk_context*, float width);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`__width__   | Holds the absolute pixel width value the next column must be#### nk_layout_row_template_endMarks the end of the row template~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cvoid nk_layout_row_template_end(struct nk_context*);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`#### nk_layout_space_beginBegins a new layouting space that allows to specify each widgets position and size.~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cvoid nk_layout_space_begin(struct nk_context*, enum nk_layout_format, float height, int widget_count);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to an previously initialized `nk_context` struct after call `nk_begin_xxx`__fmt__     | Either `NK_DYNAMIC` for window ratio or `NK_STATIC` for fixed size columns__height__  | Holds height of each widget in row or zero for auto layouting__columns__ | Number of widgets inside row#### nk_layout_space_pushPushes position and size of the next widget in own coordinate space either as pixel or ratio~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cvoid nk_layout_space_push(struct nk_context *ctx, struct nk_rect bounds);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to an previously initialized `nk_context` struct after call `nk_layout_space_begin`__bounds__  | Position and size in laoyut space local coordinates#### nk_layout_space_endMarks the end of the layout space~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cvoid nk_layout_space_end(struct nk_context*);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to an previously initialized `nk_context` struct after call `nk_layout_space_begin`#### nk_layout_space_boundsUtility 函数 to calculate total space allocated for `nk_layout_space`~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cstruct nk_rect nk_layout_space_bounds(struct nk_context*);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to an previously initialized `nk_context` struct after call `nk_layout_space_begin`Returns `nk_rect` holding the total space allocated#### nk_layout_space_to_screenConverts vector from nk_layout_space coordinate space into screen space~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cstruct nk_vec2 nk_layout_space_to_screen(struct nk_context*, struct nk_vec2);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to an previously initialized `nk_context` struct after call `nk_layout_space_begin`__vec__     | Position to convert from layout space into screen coordinate spaceReturns transformed `nk_vec2` in screen space coordinates#### nk_layout_space_to_screenConverts vector from layout space into screen space~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cstruct nk_vec2 nk_layout_space_to_local(struct nk_context*, struct nk_vec2);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to an previously initialized `nk_context` struct after call `nk_layout_space_begin`__vec__     | Position to convert from screen space into layout coordinate spaceReturns transformed `nk_vec2` in layout space coordinates#### nk_layout_space_rect_to_screenConverts rectangle from screen space into layout space~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cstruct nk_rect nk_layout_space_rect_to_screen(struct nk_context*, struct nk_rect);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to an previously initialized `nk_context` struct after call `nk_layout_space_begin`__bounds__  | Rectangle to convert from layout space into screen spaceReturns transformed `nk_rect` in screen space coordinates#### nk_layout_space_rect_to_localConverts rectangle from layout space into screen space~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cstruct nk_rect nk_layout_space_rect_to_local(struct nk_context*, struct nk_rect);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to an previously initialized `nk_context` struct after call `nk_layout_space_begin`__bounds__  | Rectangle to convert from layout space into screen spaceReturns transformed `nk_rect` in layout space coordinates### GroupsGroups 基本上都是窗口(window)中的窗口。They allow to subdivide spacein a window to layout widgets as a group. Almost all more complex widgetlayouting requirements can be solved using groups and basic layoutingfuctionality. Groups just like windows are identified by an unique name andinternally keep track of scrollbar offsets by default. However additionalversions are provided to directly manage the scrollbar.#### Usage 用法To create a group you have to call one of the three `nk_group_begin_xxx`函数s to start group declarations and `nk_group_end` at the end. Furthermore itis required to check the return value of `nk_group_begin_xxx` and only processwidgets inside the window if the value is not 0.Nesting groups is possible and even encouraged since many layouting schemescan only be achieved by nesting. Groups, unlike windows, need `nk_group_end`to be only called if the corosponding `nk_group_begin_xxx` call does not return 0:~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cif (nk_group_begin_xxx(ctx, ...) {    // [... widgets ...]    nk_group_end(ctx);}~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~In the grand concept groups can be called after starting a windowwith `nk_begin_xxx` and before calling `nk_end`:~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cstruct nk_context ctx;nk_init_xxx(&ctx, ...);while (1) {    // Input    Event evt;    nk_input_begin(&ctx);    while (GetEvent(&evt)) {        if (evt.type == MOUSE_MOVE)            nk_input_motion(&ctx, evt.motion.x, evt.motion.y);        else if (evt.type == [...]) {            nk_input_xxx(...);        }    }    nk_input_end(&ctx);    //    // Window    if (nk_begin_xxx(...) {        // [...widgets...]        nk_layout_row_dynamic(...);        if (nk_group_begin_xxx(ctx, ...) {            //[... widgets ...]            nk_group_end(ctx);        }    }    nk_end(ctx);    //    // Draw    const struct nk_command *cmd = 0;    nk_foreach(cmd, &ctx) {    switch (cmd->type) {    case NK_COMMAND_LINE:        your_draw_line_函数(...)        break;    case NK_COMMAND_RECT        your_draw_rect_函数(...)        break;    case ...:        // [...]    }}nk_free(&ctx);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#### Reference函数                        | 描述--------------------------------|-------------------------------------------nk_group_begin                  | Start a new group with internal scrollbar handlingnk_group_begin_titled           | Start a new group with separeted name and title and internal scrollbar handlingnk_group_end                    | Ends a group. Should only be called if nk_group_begin returned non-zeronk_group_scrolled_offset_begin  | Start a new group with manual separated handling of scrollbar x- and y-offsetnk_group_scrolled_begin         | Start a new group with manual scrollbar handlingnk_group_scrolled_end           | Ends a group with manual scrollbar handling. Should only be called if nk_group_begin returned non-zero#### nk_group_beginStarts a new widget group. Requires a previous layouting 函数 to specify a pos/size.~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cint nk_group_begin(struct nk_context*, const char *title, nk_flags);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to an previously initialized `nk_context` struct__title__   | Must be an unique identifier for this group that is also used for the group header__flags__   | Window flags defined in the nk_panel_flags section with a number of different group behaviorsReturns `true(1)` if visible and fillable with widgets or `false(0)` otherwise#### nk_group_begin_titledStarts a new widget group. Requires a previous layouting 函数 to specify a pos/size.~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cint nk_group_begin_titled(struct nk_context*, const char *name, const char *title, nk_flags);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to an previously initialized `nk_context` struct__id__      | Must be an unique identifier for this group__title__   | Group header title__flags__   | Window flags defined in the nk_panel_flags section with a number of different group behaviorsReturns `true(1)` if visible and fillable with widgets or `false(0)` otherwise#### nk_group_endEnds a widget group~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cvoid nk_group_end(struct nk_context*);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to an previously initialized `nk_context` struct#### nk_group_scrolled_offset_beginstarts a new widget group. requires a previous layouting 函数 to specifya size. Does not keep track of scrollbar.~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cint nk_group_scrolled_offset_begin(struct nk_context*, nk_uint *x_offset, nk_uint *y_offset, const char *title, nk_flags flags);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to an previously initialized `nk_context` struct__x_offset__| Scrollbar x-offset to offset all widgets inside the group horizontally.__y_offset__| Scrollbar y-offset to offset all widgets inside the group vertically__title__   | Window unique group title used to both identify and display in the group header__flags__   | Window flags from the nk_panel_flags sectionReturns `true(1)` if visible and fillable with widgets or `false(0)` otherwise#### nk_group_scrolled_beginStarts a new widget group. requires a previouslayouting 函数 to specify a size. Does not keep track of scrollbar.~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cint nk_group_scrolled_begin(struct nk_context*, struct nk_scroll *off, const char *title, nk_flags);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to an previously initialized `nk_context` struct__off__     | Both x- and y- scroll offset. Allows for manual scrollbar control__title__   | Window unique group title used to both identify and display in the group header__flags__   | Window flags from nk_panel_flags sectionReturns `true(1)` if visible and fillable with widgets or `false(0)` otherwise#### nk_group_scrolled_endEnds a widget group after calling nk_group_scrolled_offset_begin or nk_group_scrolled_begin.~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cvoid nk_group_scrolled_end(struct nk_context*);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to an previously initialized `nk_context` struct### TreeTrees represent two different concept. First the concept of a collapsableUI section that can be either in a hidden or visibile state. They allow the UIuser to selectively minimize the current set of visible UI to comprehend.The second concept are tree widgets for visual UI representation of trees.Trees thereby can be nested for tree representations and multiple nestedcollapsable UI sections. All trees are started by calling of the`nk_tree_xxx_push_tree` 函数s and ended by calling one of the`nk_tree_xxx_pop_xxx()` 函数s. Each starting 函数s takes a title labeland optionally an image to be displayed and the initial collapse state fromthe nk_collapse_states section.The runtime state of the tree is either stored outside the library by the calleror inside which requires a unique ID. The unique ID can either be generatedautomatically from `__FILE__` and `__LINE__` with 函数 `nk_tree_push`,by `__FILE__` and a user provided ID generated for example by loop index with函数 `nk_tree_push_id` or completely provided from outside by user with函数 `nk_tree_push_hashed`.#### Usage 用法To create a tree you have to call one of the seven `nk_tree_xxx_push_xxx`函数s to start a collapsable UI section and `nk_tree_xxx_pop` to mark theend.Each starting 函数 will either return `false(0)` if the tree is collapsedor hidden and therefore does not need to be filled with content or `true(1)`if visible and required to be filled.!!! Note    The tree header does not require and layouting 函数 and instead    calculates a auto height based on the currently used font sizeThe tree ending 函数s only need to be called if the tree content isactually visible. So make sure the tree push 函数 is guarded by `if`and the pop call is only taken if the tree is visible.~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cif (nk_tree_push(ctx, NK_TREE_TAB, "Tree", NK_MINIMIZED)) {    nk_layout_row_dynamic(...);    nk_widget(...);    nk_tree_pop(ctx);}~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#### Reference函数                    | 描述----------------------------|-------------------------------------------nk_tree_push                | Start a collapsable UI section with internal state managementnk_tree_push_id             | Start a collapsable UI section with internal state management callable in a looknk_tree_push_hashed         | Start a collapsable UI section with internal state management with full control over internal unique ID use to store statenk_tree_image_push          | Start a collapsable UI section with image and label headernk_tree_image_push_id       | Start a collapsable UI section with image and label header and internal state management callable in a looknk_tree_image_push_hashed   | Start a collapsable UI section with image and label header and internal state management with full control over internal unique ID use to store statenk_tree_pop                 | Ends a collapsable UI sectionnk_tree_state_push          | Start a collapsable UI section with external state managementnk_tree_state_image_push    | Start a collapsable UI section with image and label header and external state managementnk_tree_state_pop           | Ends a collapsabale UI section#### nk_tree_typeFlag            | 描述----------------|----------------------------------------NK_TREE_NODE    | Highlighted tree header to mark a collapsable UI sectionNK_TREE_TAB     | Non-highighted tree header closer to tree representations#### nk_tree_pushStarts a collapsable UI section with internal state management!!! WARNING    To keep track of the runtime tree collapsable state this 函数 uses    defines `__FILE__` and `__LINE__` to generate a unique ID. If you want    to call this 函数 in a loop please use `nk_tree_push_id` or    `nk_tree_push_hashed` instead.~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c#define nk_tree_push(ctx, type, title, state)~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to an previously initialized `nk_context` struct__type__    | Value from the nk_tree_type section to visually mark a tree node header as either a collapseable UI section or tree node__title__   | Label printed in the tree header__state__   | Initial tree state value out of nk_collapse_statesReturns `true(1)` if visible and fillable with widgets or `false(0)` otherwise#### nk_tree_push_idStarts a collapsable UI section with internal state management callable in a look~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c#define nk_tree_push_id(ctx, type, title, state, id)~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to an previously initialized `nk_context` struct__type__    | Value from the nk_tree_type section to visually mark a tree node header as either a collapseable UI section or tree node__title__   | Label printed in the tree header__state__   | Initial tree state value out of nk_collapse_states__id__      | Loop counter index if this 函数 is called in a loopReturns `true(1)` if visible and fillable with widgets or `false(0)` otherwise#### nk_tree_push_hashedStart a collapsable UI section with internal state management with fullcontrol over internal unique ID used to store state~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cint nk_tree_push_hashed(struct nk_context*, enum nk_tree_type, const char *title, enum nk_collapse_states initial_state, const char *hash, int len,int seed);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to an previously initialized `nk_context` struct__type__    | Value from the nk_tree_type section to visually mark a tree node header as either a collapseable UI section or tree node__title__   | Label printed in the tree header__state__   | Initial tree state value out of nk_collapse_states__hash__    | Memory block or string to generate the ID from__len__     | Size of passed memory block or string in __hash____seed__    | Seeding value if this 函数 is called in a loop or default to `0`Returns `true(1)` if visible and fillable with widgets or `false(0)` otherwise#### nk_tree_image_pushStart a collapsable UI section with image and label header!!! WARNING    To keep track of the runtime tree collapsable state this 函数 uses    defines `__FILE__` and `__LINE__` to generate a unique ID. If you want    to call this 函数 in a loop please use `nk_tree_image_push_id` or    `nk_tree_image_push_hashed` instead.~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c#define nk_tree_image_push(ctx, type, img, title, state)~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to an previously initialized `nk_context` struct__type__    | Value from the nk_tree_type section to visually mark a tree node header as either a collapseable UI section or tree node__img__     | Image to display inside the header on the left of the label__title__   | Label printed in the tree header__state__   | Initial tree state value out of nk_collapse_statesReturns `true(1)` if visible and fillable with widgets or `false(0)` otherwise#### nk_tree_image_push_idStart a collapsable UI section with image and label header and internal statemanagement callable in a look~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~c#define nk_tree_image_push_id(ctx, type, img, title, state, id)~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to an previously initialized `nk_context` struct__type__    | Value from the nk_tree_type section to visually mark a tree node header as either a collapseable UI section or tree node__img__     | Image to display inside the header on the left of the label__title__   | Label printed in the tree header__state__   | Initial tree state value out of nk_collapse_states__id__      | Loop counter index if this 函数 is called in a loopReturns `true(1)` if visible and fillable with widgets or `false(0)` otherwise#### nk_tree_image_push_hashedStart a collapsable UI section with internal state management with fullcontrol over internal unique ID used to store state~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cint nk_tree_image_push_hashed(struct nk_context*, enum nk_tree_type, struct nk_image, const char *title, enum nk_collapse_states initial_state, const char *hash, int len,int seed);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to an previously initialized `nk_context` struct__type__    | Value from the nk_tree_type section to visually mark a tree node header as either a collapseable UI section or tree node__img__     | Image to display inside the header on the left of the label__title__   | Label printed in the tree header__state__   | Initial tree state value out of nk_collapse_states__hash__    | Memory block or string to generate the ID from__len__     | Size of passed memory block or string in __hash____seed__    | Seeding value if this 函数 is called in a loop or default to `0`Returns `true(1)` if visible and fillable with widgets or `false(0)` otherwise#### nk_tree_popEnds a collapsabale UI section~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cvoid nk_tree_pop(struct nk_context*);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to an previously initialized `nk_context` struct after calling `nk_tree_xxx_push_xxx`#### nk_tree_state_pushStart a collapsable UI section with external state management~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cint nk_tree_state_push(struct nk_context*, enum nk_tree_type, const char *title, enum nk_collapse_states *state);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to an previously initialized `nk_context` struct after calling `nk_tree_xxx_push_xxx`__type__    | Value from the nk_tree_type section to visually mark a tree node header as either a collapseable UI section or tree node__title__   | Label printed in the tree header__state__   | Persistent state to updateReturns `true(1)` if visible and fillable with widgets or `false(0)` otherwise#### nk_tree_state_image_pushStart a collapsable UI section with image and label header and external state management~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cint nk_tree_state_image_push(struct nk_context*, enum nk_tree_type, struct nk_image, const char *title, enum nk_collapse_states *state);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to an previously initialized `nk_context` struct after calling `nk_tree_xxx_push_xxx`__img__     | Image to display inside the header on the left of the label__type__    | Value from the nk_tree_type section to visually mark a tree node header as either a collapseable UI section or tree node__title__   | Label printed in the tree header__state__   | Persistent state to updateReturns `true(1)` if visible and fillable with widgets or `false(0)` otherwise#### nk_tree_state_popEnds a collapsabale UI section~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cvoid nk_tree_state_pop(struct nk_context*);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数   | 描述------------|-----------------------------------------------------------__ctx__     | Must point to an previously initialized `nk_context` struct after calling `nk_tree_xxx_push_xxx`### PropertiesProperties are the main value modification widgets in Nuklear. Changing a valuecan be achieved by dragging, adding/removing incremental steps on button clickor by directly typing a number.#### Usage 用法Each property requires a unique name for identifaction that is also used fordisplaying a label. If you want to use the same name multiple times make sureadd a '#' before your name. The '#' will not be shown but will generate aunique ID. Each propery also takes in a minimum and maximum value. If you wantto make use of the complete number range of a type just use the providedtype limits from `limits.h`. For example `INT_MIN` and `INT_MAX` for`nk_property_int` and `nk_propertyi`. In additional each property takes ina increment value that will be added or subtracted if either the incrementdecrement button is clicked. Finally there is a value for increment per pixeldragged that is added or subtracted from the value.~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cint value = 0;struct nk_context ctx;nk_init_xxx(&ctx, ...);while (1) {    // Input    Event evt;    nk_input_begin(&ctx);    while (GetEvent(&evt)) {        if (evt.type == MOUSE_MOVE)            nk_input_motion(&ctx, evt.motion.x, evt.motion.y);        else if (evt.type == [...]) {            nk_input_xxx(...);        }    }    nk_input_end(&ctx);    //    // Window    if (nk_begin_xxx(...) {        // Property        nk_layout_row_dynamic(...);        nk_property_int(ctx, "ID", INT_MIN, &value, INT_MAX, 1, 1);    }    nk_end(ctx);    //    // Draw    const struct nk_command *cmd = 0;    nk_foreach(cmd, &ctx) {    switch (cmd->type) {    case NK_COMMAND_LINE:        your_draw_line_函数(...)        break;    case NK_COMMAND_RECT        your_draw_rect_函数(...)        break;    case ...:        // [...]    }}nk_free(&ctx);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#### Reference函数            | 描述--------------------|-------------------------------------------nk_property_int     | Integer property directly modifing a passed in valuenk_property_float   | Float property directly modifing a passed in valuenk_property_double  | Double property directly modifing a passed in valuenk_propertyi        | Integer property returning the modified int valuenk_propertyf        | Float property returning the modified float valuenk_propertyd        | Double property returning the modified double value#### nk_property_intInteger property directly modifing a passed in value!!! WARNING    To generate a unique property ID using the same label make sure to insert    a `#` at the beginning. It will not be shown but guarantees correct behavior.~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cvoid nk_property_int(struct nk_context *ctx, const char *name, int min, int *val, int max, int step, float inc_per_pixel);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数           | 描述--------------------|-----------------------------------------------------------__ctx__             | Must point to an previously initialized `nk_context` struct after calling a layouting 函数__name__            | String used both as a label as well as a unique identifier__min__             | Minimum value not allowed to be underflown__val__             | Integer pointer to be modified__max__             | Maximum value not allowed to be overflown__step__            | Increment added and subtracted on increment and decrement button__inc_per_pixel__   | Value per pixel added or subtracted on dragging#### nk_property_floatFloat property directly modifing a passed in value!!! WARNING    To generate a unique property ID using the same label make sure to insert    a `#` at the beginning. It will not be shown but guarantees correct behavior.~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cvoid nk_property_float(struct nk_context *ctx, const char *name, float min, float *val, float max, float step, float inc_per_pixel);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数           | 描述--------------------|-----------------------------------------------------------__ctx__             | Must point to an previously initialized `nk_context` struct after calling a layouting 函数__name__            | String used both as a label as well as a unique identifier__min__             | Minimum value not allowed to be underflown__val__             | Float pointer to be modified__max__             | Maximum value not allowed to be overflown__step__            | Increment added and subtracted on increment and decrement button__inc_per_pixel__   | Value per pixel added or subtracted on dragging#### nk_property_doubleDouble property directly modifing a passed in value!!! WARNING    To generate a unique property ID using the same label make sure to insert    a `#` at the beginning. It will not be shown but guarantees correct behavior.~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cvoid nk_property_double(struct nk_context *ctx, const char *name, double min, double *val, double max, double step, double inc_per_pixel);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数           | 描述--------------------|-----------------------------------------------------------__ctx__             | Must point to an previously initialized `nk_context` struct after calling a layouting 函数__name__            | String used both as a label as well as a unique identifier__min__             | Minimum value not allowed to be underflown__val__             | Double pointer to be modified__max__             | Maximum value not allowed to be overflown__step__            | Increment added and subtracted on increment and decrement button__inc_per_pixel__   | Value per pixel added or subtracted on dragging#### nk_propertyiInteger property modifing a passed in value and returning the new value!!! WARNING    To generate a unique property ID using the same label make sure to insert    a `#` at the beginning. It will not be shown but guarantees correct behavior.~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cint nk_propertyi(struct nk_context *ctx, const char *name, int min, int val, int max, int step, float inc_per_pixel);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数           | 描述--------------------|-----------------------------------------------------------__ctx__             | Must point to an previously initialized `nk_context` struct after calling a layouting 函数__name__            | String used both as a label as well as a unique identifier__min__             | Minimum value not allowed to be underflown__val__             | Current integer value to be modified and returned__max__             | Maximum value not allowed to be overflown__step__            | Increment added and subtracted on increment and decrement button__inc_per_pixel__   | Value per pixel added or subtracted on draggingReturns the new modified integer value#### nk_propertyfFloat property modifing a passed in value and returning the new value!!! WARNING    To generate a unique property ID using the same label make sure to insert    a `#` at the beginning. It will not be shown but guarantees correct behavior.~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cfloat nk_propertyf(struct nk_context *ctx, const char *name, float min, float val, float max, float step, float inc_per_pixel);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数           | 描述--------------------|-----------------------------------------------------------__ctx__             | Must point to an previously initialized `nk_context` struct after calling a layouting 函数__name__            | String used both as a label as well as a unique identifier__min__             | Minimum value not allowed to be underflown__val__             | Current float value to be modified and returned__max__             | Maximum value not allowed to be overflown__step__            | Increment added and subtracted on increment and decrement button__inc_per_pixel__   | Value per pixel added or subtracted on draggingReturns the new modified float value#### nk_propertydFloat property modifing a passed in value and returning the new value!!! WARNING    To generate a unique property ID using the same label make sure to insert    a `#` at the beginning. It will not be shown but guarantees correct behavior.~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~cfloat nk_propertyd(struct nk_context *ctx, const char *name, double min, double val, double max, double step, double inc_per_pixel);~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~参数           | 描述--------------------|-----------------------------------------------------------__ctx__             | Must point to an previously initialized `nk_context` struct after calling a layouting 函数__name__            | String used both as a label as well as a unique identifier__min__             | Minimum value not allowed to be underflown__val__             | Current double value to be modified and returned__max__             | Maximum value not allowed to be overflown__step__            | Increment added and subtracted on increment and decrement button__inc_per_pixel__   | Value per pixel added or subtracted on draggingReturns the new modified double value        -XXX.XXX-  X...X  -         X...X         -X....X           -           X....X"X...XXXXXXXXXXXXX...X -           "## 许可协议~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~none   ------------------------------------------------------------------------------   This software is available under 2 licenses -- choose whichever you prefer.   ------------------------------------------------------------------------------   ALTERNATIVE A - MIT License   Copyright (c) 2016-2018 Micha Mettke   Permission is hereby granted, free of charge, to any person obtaining a copy of   this software and associated documentation files (the "Software"), to deal in   the Software without restriction, including without limitation the rights to   use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies   of the Software, and to permit persons to whom the Software is furnished to do   so, subject to the following conditions:   The above copyright notice and this permission notice shall be included in all   copies or substantial portions of the Software.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE   SOFTWARE.   ------------------------------------------------------------------------------   ALTERNATIVE B - Public Domain (www.unlicense.org)   This is free and unencumbered software released into the public domain.   Anyone is free to copy, modify, publish, use, compile, sell, or distribute this   software, either in source code form or as a compiled binary, for any purpose,   commercial or non-commercial, and by any means.   In jurisdictions that recognize copyright laws, the author or authors of this   software dedicate any and all copyright interest in the software to the public   domain. We make this dedication for the benefit of the public at large and to   the detriment of our heirs and successors. We intend this dedication to be an   overt act of relinquishment in perpetuity of all present and future rights to   this software under copyright law.   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE   AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION   WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.   ------------------------------------------------------------------------------~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~## 更新日志~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~none[date][x.yy.zz]-[描述]-[date]: date on which the change has been pushed-[x.yy.zz]: Numerical version string representation. Each version number on the right            resets back to zero if version on the left is incremented.   - [x]: Major version with API and library breaking changes   - [yy]: Minor version with non-breaking API and library changes   - [zz]: Bug fix version with no direct changes to API- 2018/04/01 (4.00.1) - Fixed calling `nk_convert` multiple time per single frame- 2018/04/01 (4.00.0) - BREAKING CHANGE: nk_draw_list_clear no longer tries to                        clear provided buffers. So make sure to either free                        or clear each passed buffer after calling nk_convert.- 2018/02/23 (3.00.6) - Fixed slider dragging behavior- 2018/01/31 (3.00.5) - Fixed overcalculation of cursor data in font baking process- 2018/01/31 (3.00.4) - Removed name collision with stb_truetype- 2018/01/28 (3.00.3) - Fixed panel window border drawing bug- 2018/01/12 (3.00.2) - Added `nk_group_begin_titled` for separed group identifier and title- 2018/01/07 (3.00.1) - Started to change documentation style- 2018/01/05 (3.00.0) - BREAKING CHANGE: The previous color picker API was broken                       because of conversions between float and byte color representation.                       Color pickers now use floating point values to represent                       HSV values. To get back the old behavior I added some additional                       color conversion 函数s to cast between nk_color and                       nk_colorf.- 2017/12/23 (2.00.7) - Fixed small warning- 2017/12/23 (2.00.7) - Fixed nk_edit_buffer behavior if activated to allow input- 2017/12/23 (2.00.7) - Fixed modifyable progressbar dragging visuals and input behavior- 2017/12/04 (2.00.6) - Added formated string tooltip widget- 2017/11/18 (2.00.5) - Fixed window becoming hidden with flag NK_WINDOW_NO_INPUT- 2017/11/15 (2.00.4) - Fixed font merging- 2017/11/07 (2.00.3) - Fixed window size and position modifier 函数s- 2017/09/14 (2.00.2) - Fixed nk_edit_buffer and nk_edit_focus behavior- 2017/09/14 (2.00.1) - Fixed window closing behavior- 2017/09/14 (2.00.0) - BREAKING CHANGE: Modifing window position and size funtions now                       require the name of the window and must happen outside the window                       building process (between 函数 call nk_begin and nk_end).- 2017/09/11 (1.40.9) - Fixed window background flag if background window is declared last- 2017/08/27 (1.40.8) - Fixed `nk_item_is_any_active` for hidden windows- 2017/08/27 (1.40.7) - Fixed window background flag- 2017/07/07 (1.40.6) - Fixed missing clipping rect check for hovering/clicked                       query for widgets- 2017/07/07 (1.40.5) - Fixed drawing bug for vertex output for lines and stroked                       and filled rectangles- 2017/07/07 (1.40.4) - Fixed bug in nk_convert trying to add windows that are in                       process of being destroyed.- 2017/07/07 (1.40.3) - Fixed table internal bug caused by storing table size in                       window instead of directly in table.- 2017/06/30 (1.40.2) - Removed unneeded semicolon in C++ NK_ALIGNOF macro- 2017/06/30 (1.40.1) - Fixed drawing lines smaller or equal zero- 2017/06/08 (1.40.0) - Removed the breaking part of last commit. Auto layout now only                       comes in effect if you pass in zero was row height argument- 2017/06/08 (1.40.0) - BREAKING CHANGE: while not directly API breaking it will change                       how layouting works. From now there will be an internal minimum                       row height derived from font height. If you need a row smaller than                       that you can directly set it by `nk_layout_set_min_row_height` and                       reset the value back by calling `nk_layout_reset_min_row_height.- 2017/06/08 (1.39.1) - Fixed property text edit handling bug caused by past `nk_widget` fix- 2017/06/08 (1.39.0) - Added 函数 to retrieve window space without calling a nk_layout_xxx 函数- 2017/06/06 (1.38.5) - Fixed `nk_convert` return flag for command buffer- 2017/05/23 (1.38.4) - Fixed activation behavior for widgets partially clipped- 2017/05/10 (1.38.3) - Fixed wrong min window size mouse scaling over boundries- 2017/05/09 (1.38.2) - Fixed vertical scrollbar drawing with not enough space- 2017/05/09 (1.38.1) - Fixed scaler dragging behavior if window size hits minimum size- 2017/05/06 (1.38.0) - Added platform double-click support- 2017/04/20 (1.37.1) - Fixed key repeat found inside glfw demo backends- 2017/04/20 (1.37.0) - Extended properties with selection and clipbard support- 2017/04/20 (1.36.2) - Fixed #405 overlapping rows with zero padding and spacing- 2017/04/09 (1.36.1) - Fixed #403 with another widget float error- 2017/04/09 (1.36.0) - Added window `NK_WINDOW_NO_INPUT` and `NK_WINDOW_NOT_INTERACTIVE` flags- 2017/04/09 (1.35.3) - Fixed buffer heap corruption- 2017/03/25 (1.35.2) - Fixed popup overlapping for `NK_WINDOW_BACKGROUND` windows- 2017/03/25 (1.35.1) - Fixed windows closing behavior- 2017/03/18 (1.35.0) - Added horizontal scroll requested in #377- 2017/03/18 (1.34.3) - Fixed long window header titles- 2017/03/04 (1.34.2) - Fixed text edit filtering- 2017/03/04 (1.34.1) - Fixed group closable flag- 2017/02/25 (1.34.0) - Added custom draw command for better language binding support- 2017/01/24 (1.33.0) - Added programatic way of remove edit focus- 2017/01/24 (1.32.3) - Fixed wrong define for basic type definitions for windows- 2017/01/21 (1.32.2) - Fixed input capture from hidden or closed windows- 2017/01/21 (1.32.1) - Fixed slider behavior and drawing- 2017/01/13 (1.32.0) - Added flag to put scaler into the bottom left corner- 2017/01/13 (1.31.0) - Added additional row layouting method to combine both                       dynamic and static widgets.- 2016/12/31 (1.30.0) - Extended scrollbar offset from 16-bit to 32-bit- 2016/12/31 (1.29.2)- Fixed closing window bug of minimized windows- 2016/12/03 (1.29.1)- Fixed wrapped text with no seperator and C89 error- 2016/12/03 (1.29.0) - Changed text wrapping to process words not characters- 2016/11/22 (1.28.6)- Fixed window minimized closing bug- 2016/11/19 (1.28.5)- Fixed abstract combo box closing behavior- 2016/11/19 (1.28.4)- Fixed tooltip flickering- 2016/11/19 (1.28.3)- Fixed memory leak caused by popup repeated closing- 2016/11/18 (1.28.2)- Fixed memory leak caused by popup panel allocation- 2016/11/10 (1.28.1)- Fixed some warnings and C++ error- 2016/11/10 (1.28.0)- Added additional `nk_button` versions which allows to directly                       pass in a style struct to change buttons visual.- 2016/11/10 (1.27.0)- Added additional 'nk_tree' versions to support external state                       storage. Just like last the `nk_group` commit the main                       advantage is that you optionally can minimize nuklears runtime                       memory consumption or handle hash collisions.- 2016/11/09 (1.26.0)- Added additional `nk_group` version to support external scrollbar                       offset storage. Main advantage is that you can externalize                       the memory management for the offset. It could also be helpful                       if you have a hash collision in `nk_group_begin` but really                       want the name. In addition I added `nk_list_view` which allows                       to draw big lists inside a group without actually having to                       commit the whole list to nuklear (issue #269).- 2016/10/30 (1.25.1)- Fixed clipping rectangle bug inside `nk_draw_list`- 2016/10/29 (1.25.0)- Pulled `nk_panel` memory management into nuklear and out of                       the hands of the user. From now on users don't have to care                       about panels unless they care about some information. If you                       still need the panel just call `nk_window_get_panel`.- 2016/10/21 (1.24.0)- Changed widget border drawing to stroked rectangle from filled                       rectangle for less overdraw and widget background transparency.- 2016/10/18 (1.23.0)- Added `nk_edit_focus` for manually edit widget focus control- 2016/09/29 (1.22.7)- Fixed deduction of basic type in non `<stdint.h>` compilation- 2016/09/29 (1.22.6)- Fixed edit widget UTF-8 text cursor drawing bug- 2016/09/28 (1.22.5)- Fixed edit widget UTF-8 text appending/inserting/removing- 2016/09/28 (1.22.4)- Fixed drawing bug inside edit widgets which offset all text                       text in every edit widget if one of them is scrolled.- 2016/09/28 (1.22.3)- Fixed small bug in edit widgets if not active. The wrong                       text length is passed. It should have been in bytes but                       was passed as glyphes.- 2016/09/20 (1.22.2)- Fixed color button size calculation- 2016/09/20 (1.22.1)- Fixed some `nk_vsnprintf` behavior bugs and removed                       `<stdio.h>` again from `NK_INCLUDE_STANDARD_VARARGS`.- 2016/09/18 (1.22.0)- C89 does not support vsnprintf only C99 and newer as well                       as C++11 and newer. In addition to use vsnprintf you have                       to include <stdio.h>. So just defining `NK_INCLUDE_STD_VAR_ARGS`                       is not enough. That behavior is now fixed. By default if                       both varargs as well as stdio is selected I try to use                       vsnprintf if not possible I will revert to vsprintf. If                       varargs but not stdio was defined I will use my own 函数.- 2016/09/15 (1.21.2)- Fixed panel `close` behavior for deeper panel levels- 2016/09/15 (1.21.1)- Fixed C++ errors and wrong argument to `nk_panel_get_xxxx`- 2016/09/13 (1.21.0) - !BREAKING! Fixed nonblocking popup behavior in menu, combo,                       and contextual which prevented closing in y-direction if                       popup did not reach max height.                       In addition the height 参数 was changed into vec2                       for width and height to have more control over the popup size.- 2016/09/13 (1.20.3) - Cleaned up and extended type selection- 2016/09/13 (1.20.2)- Fixed slider behavior hopefully for the last time. This time                       all calculation are correct so no more hackery.- 2016/09/13 (1.20.1)- Internal change to divide window/panel flags into panel flags and types.                       Suprisinly spend years in C and still happened to confuse types                       with flags. Probably something to take note.- 2016/09/08 (1.20.0)- Added additional helper 函数 to make it easier to just                       take the produced buffers from `nk_convert` and unplug the                       iteration process from `nk_context`. So now you can                       just use the vertex,element and command buffer + two pointer                       inside the command buffer retrieved by calls `nk__draw_begin`                       and `nk__draw_end` and macro `nk_draw_foreach_bounded`.- 2016/09/08 (1.19.0)- Added additional asserts to make sure every `nk_xxx_begin` call                       for windows, popups, combobox, menu and contextual is guarded by                       `if` condition and does not produce false drawing output.- 2016/09/08 (1.18.0)- Changed confusing name for `NK_SYMBOL_RECT_FILLED`, `NK_SYMBOL_RECT`                       to hopefully easier to understand `NK_SYMBOL_RECT_FILLED` and                       `NK_SYMBOL_RECT_OUTLINE`.- 2016/09/08 (1.17.0)- Changed confusing name for `NK_SYMBOL_CIRLCE_FILLED`, `NK_SYMBOL_CIRCLE`                       to hopefully easier to understand `NK_SYMBOL_CIRCLE_FILLED` and                       `NK_SYMBOL_CIRCLE_OUTLINE`.- 2016/09/08 (1.16.0)- Added additional checks to select correct types if `NK_INCLUDE_FIXED_TYPES`                       is not defined by supporting the biggest compiler GCC, clang and MSVC.- 2016/09/07 (1.15.3)- Fixed `NK_INCLUDE_COMMAND_USERDATA` define to not cause an error- 2016/09/04 (1.15.2)- Fixed wrong combobox height calculation- 2016/09/03 (1.15.1)- Fixed gaps inside combo boxes in OpenGL- 2016/09/02 (1.15.0) - Changed nuklear to not have any default vertex layout and                       instead made it user provided. The range of types to convert                       to is quite limited at the moment, but I would be more than                       happy to accept PRs to add additional.- 2016/08/30 (1.14.2) - Removed unused variables- 2016/08/30 (1.14.1) - Fixed C++ build errors- 2016/08/30 (1.14.0) - Removed mouse dragging from SDL demo since it does not work correctly- 2016/08/30 (1.13.4) - Tweaked some default styling variables- 2016/08/30 (1.13.3) - Hopefully fixed drawing bug in slider, in general I would                       refrain from using slider with a big number of steps.- 2016/08/30 (1.13.2) - Fixed close and minimize button which would fire even if the                       window was in Read Only Mode.- 2016/08/30 (1.13.1) - Fixed popup panel padding handling which was previously just                       a hack for combo box and menu.- 2016/08/30 (1.13.0) - Removed `NK_WINDOW_DYNAMIC` flag from public API since                       it is bugged and causes issues in window selection.- 2016/08/30 (1.12.0) - Removed scaler size. The size of the scaler is now                       determined by the scrollbar size- 2016/08/30 (1.11.2) - Fixed some drawing bugs caused by changes from 1.11- 2016/08/30 (1.11.1) - Fixed overlapping minimized window selection- 2016/08/30 (1.11.0) - Removed some internal complexity and overly complex code                       handling panel padding and panel border.- 2016/08/29 (1.10.0) - Added additional height 参数 to `nk_combobox_xxx`- 2016/08/29 (1.10.0) - Fixed drawing bug in dynamic popups- 2016/08/29 (1.10.0) - Added experimental mouse scrolling to popups, menus and comboboxes- 2016/08/26 (1.10.0) - Added window name string prepresentation to account for                       hash collisions. Currently limited to NK_WINDOW_MAX_NAME                       which in term can be redefined if not big enough.- 2016/08/26 (1.10.0) - Added stacks for temporary style/UI changes in code- 2016/08/25 (1.10.0) - Changed `nk_input_is_key_pressed` and 'nk_input_is_key_released'                       to account for key press and release happening in one frame.- 2016/08/25 (1.10.0) - Added additional nk_edit flag to directly jump to the end on activate- 2016/08/17 (1.09.6)- Removed invalid check for value zero in nk_propertyx- 2016/08/16 (1.09.5)- Fixed ROM mode for deeper levels of popup windows parents.- 2016/08/15 (1.09.4)- Editbox are now still active if enter was pressed with flag                       `NK_EDIT_SIG_ENTER`. Main reasoning is to be able to keep                       typing after commiting.- 2016/08/15 (1.09.4)- Removed redundant code- 2016/08/15 (1.09.4)- Fixed negative numbers in `nk_strtoi` and remove unused variable- 2016/08/15 (1.09.3)- Fixed `NK_WINDOW_BACKGROUND` flag behavior to select a background                       window only as selected by hovering and not by clicking.- 2016/08/14 (1.09.2)- Fixed a bug in font atlas which caused wrong loading                       of glyphes for font with multiple ranges.- 2016/08/12 (1.09.1)- Added additional 函数 to check if window is currently                       hidden and therefore not visible.- 2016/08/12 (1.09.1)- nk_window_is_closed now queries the correct flag `NK_WINDOW_CLOSED`                       instead of the old flag `NK_WINDOW_HIDDEN`- 2016/08/09 (1.09.0) - Added additional double version to nk_property and changed                       the underlying implementation to not cast to float and instead                       work directly on the given values.- 2016/08/09 (1.08.0) - Added additional define to overwrite library internal                       floating pointer number to string conversion for additional                       precision.- 2016/08/09 (1.08.0) - Added additional define to overwrite library internal                       string to floating point number conversion for additional                       precision.- 2016/08/08 (1.07.2)- Fixed compiling error without define NK_INCLUDE_FIXED_TYPE- 2016/08/08 (1.07.1)- Fixed possible floating point error inside `nk_widget` leading                       to wrong wiget width calculation which results in widgets falsly                       becomming tagged as not inside window and cannot be accessed.- 2016/08/08 (1.07.0) - Nuklear now differentiates between hiding a window (NK_WINDOW_HIDDEN) and                       closing a window (NK_WINDOW_CLOSED). A window can be hidden/shown                       by using `nk_window_show` and closed by either clicking the close                       icon in a window or by calling `nk_window_close`. Only closed                       windows get removed at the end of the frame while hidden windows                       remain.- 2016/08/08 (1.06.0) - Added `nk_edit_string_zero_terminated` as a second option to                       `nk_edit_string` which takes, edits and outputs a '\0' terminated string.- 2016/08/08 (1.05.4)- Fixed scrollbar auto hiding behavior- 2016/08/08 (1.05.3)- Fixed wrong panel padding selection in `nk_layout_widget_space`- 2016/08/07 (1.05.2)- Fixed old bug in dynamic immediate mode layout API, calculating                       wrong item spacing and panel width.                       define NK_INCLUDE_STANDARD_VARARGS to allow more fine                       grained controlled over library includes.- 2016/08/06 (1.04.5)- Changed memset calls to NK_MEMSET- 2016/08/04 (1.04.4)- Fixed fast window scaling behavior- 2016/08/04 (1.04.3)- Fixed window scaling, movement bug which appears if you                       move/scale a window and another window is behind it.                       If you are fast enough then the window behind gets activated                       and the operation is blocked. I now require activating                       by hovering only if mouse is not pressed.- 2016/08/04 (1.04.2)- Fixed changing fonts- 2016/08/03 (1.04.1)- Fixed `NK_WINDOW_BACKGROUND` behavior- 2016/08/03 (1.04.0) - Added color 参数 to `nk_draw_image`- 2016/08/03 (1.04.0) - Added additional window padding style attributes for                       sub windows (combo, menu, ...)- 2016/08/03 (1.04.0) - Added 函数s to show/hide software cursor- 2016/08/03 (1.04.0) - Added `NK_WINDOW_BACKGROUND` flag to force a window                       to be always in the background of the screen- 2016/08/03 (1.03.2)- Removed invalid assert macro for NK_RGB color picker- 2016/08/01 (1.03.1)- Added helper macros into header include guard- 2016/07/29 (1.03.0) - Moved the window/table pool into the header part to                       simplify memory management by removing the need to                       allocate the pool.- 2016/07/29 (1.02.0) - Added auto scrollbar hiding window flag which if enabled                       will hide the window scrollbar after NK_SCROLLBAR_HIDING_TIMEOUT                       seconds without window interaction. To make it work                       you have to also set a delta time inside the `nk_context`.- 2016/07/25 (1.01.1) - Fixed small panel and panel border drawing bugs- 2016/07/15 (1.01.0) - Added software cursor to `nk_style` and `nk_context`- 2016/07/15 (1.01.0) - Added const correctness to `nk_buffer_push' data argument- 2016/07/15 (1.01.0) - Removed internal font baking API and simplified                       font atlas memory management by converting pointer                       arrays for fonts and font configurations to lists.- 2016/07/15 (1.00.0) - Changed button API to use context dependend button                       behavior instead of passing it for every 函数 call.~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~## 画廊![Figure [blue]: Feature overview with blue color styling](https://cloud.githubusercontent.com/assets/8057201/13538240/acd96876-e249-11e5-9547-5ac0b19667a0.png)![Figure [red]: Feature overview with red color styling](https://cloud.githubusercontent.com/assets/8057201/13538243/b04acd4c-e249-11e5-8fd2-ad7744a5b446.png)![Figure [widgets]: Widget overview](https://cloud.githubusercontent.com/assets/8057201/11282359/3325e3c6-8eff-11e5-86cb-cf02b0596087.png)![Figure [blackwhite]: Black and white](https://cloud.githubusercontent.com/assets/8057201/11033668/59ab5d04-86e5-11e5-8091-c56f16411565.png)![Figure [filexp]: File explorer](https://cloud.githubusercontent.com/assets/8057201/10718115/02a9ba08-7b6b-11e5-950f-adacdd637739.png)![Figure [opengl]: OpenGL Editor](https://cloud.githubusercontent.com/assets/8057201/12779619/2a20d72c-ca69-11e5-95fe-4edecf820d5c.png)![Figure [nodedit]: Node Editor](https://cloud.githubusercontent.com/assets/8057201/9976995/e81ac04a-5ef7-11e5-872b-acd54fbeee03.gif)![Figure [skinning]: Using skinning in Nuklear](https://cloud.githubusercontent.com/assets/8057201/15991632/76494854-30b8-11e6-9555-a69840d0d50b.png)![Figure [bf]: Heavy modified version](https://cloud.githubusercontent.com/assets/8057201/14902576/339926a8-0d9c-11e6-9fee-a8b73af04473.png)## 荣誉名单Developed by Micha Mettke and every direct or indirect github contributor. Embeds [stb_texedit](https://github.com/nothings/stb/blob/master/stb_textedit.h), [stb_truetype](https://github.com/nothings/stb/blob/master/stb_truetype.h) and [stb_rectpack](https://github.com/nothings/stb/blob/master/stb_rect_pack.h) by Sean Barret (public domain) Uses [stddoc.c](https://github.com/r-lyeh/stddoc.c) from r-lyeh@github.com for documentation generation Embeds ProggyClean.ttf font by Tristan Grimmer (MIT license). Big thank you to Omar Cornut (ocornut@github) for his [imgui library](https://github.com/ocornut/imgui) andgiving me the inspiration for this library, Casey Muratori for handmade heroand his original immediate mode graphical user interface idea and SeanBarret for his amazing single header libraries which restored my faithin libraries and brought me to create some of my own. Finally Apoorva Joshifor his single header file packer.<script>markdeepOptions={tocStyle:'medium'};</script>
<!-- Markdeep: --><script src='https://casual-effects.com/markdeep/latest/markdeep.min.js?'></script>
